**====================================**
path: account-service/target/classes/application.properties
contents:
# Server Configuration
server.port=8081
spring.application.name=account-service

# === Atomikos JTA Configuration ===
# Включаем JTA (хотя стартер делает это, явно не помешает)
spring.jta.enabled=true

# --- Atomikos Core Settings (опционально, можно настроить таймауты и логи) ---
spring.jta.atomikos.properties.service=com.atomikos.icatch.standalone.UserTransactionServiceFactory
# Увеличим таймаут транзакции по умолчанию (например, до 300 секунд)
spring.jta.atomikos.properties.max-timeout=300000
spring.jta.atomikos.properties.enable-logging=true
# Уровень логгирования Atomikos (WARN, INFO, DEBUG, TRACE)
# logging.level.com.atomikos=TRACE # Очень подробно, для отладки

# --- Atomikos XA DataSource Configuration (вместо spring.datasource) ---
# Уникальное имя ресурса для Atomikos (важно!)
spring.jta.atomikos.datasource.unique-resource-name=accountPostgresXA
# Класс XA DataSource для PostgreSQL
spring.jta.atomikos.datasource.xa-data-source-class-name=org.postgresql.xa.PGXADataSource
# Свойства для XA DataSource (передаются в PGXADataSource)
spring.jta.atomikos.datasource.xa-properties.user=${POSTGRES_ACCOUNT_USER:account_user}
spring.jta.atomikos.datasource.xa-properties.password=${POSTGRES_ACCOUNT_PASSWORD:your_account_password}
spring.jta.atomikos.datasource.xa-properties.url=${POSTGRES_ACCOUNT_URL:jdbc:postgresql://localhost:5432/account_db}
# Настройки пула соединений для этого DataSource (Atomikos управляет пулом)
spring.jta.atomikos.datasource.max-pool-size=10
spring.jta.atomikos.datasource.min-pool-size=2
# Запрос для проверки соединения
spring.jta.atomikos.datasource.test-query=SELECT 1

# --- Atomikos XA JMS ConnectionFactory Configuration (вместо spring.activemq) ---
# Уникальное имя ресурса для Atomikos (важно!)
spring.jta.atomikos.connectionfactory.unique-resource-name=activemqXA
# Класс XA ConnectionFactory для ActiveMQ
spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name=org.apache.activemq.ActiveMQXAConnectionFactory
# Свойства для XA ConnectionFactory
spring.jta.atomikos.connectionfactory.xa-properties.broker-url=${ACTIVEMQ_BROKER_URL:tcp://localhost:61616}
spring.jta.atomikos.connectionfactory.xa-properties.user=${ACTIVEMQ_USER:}
spring.jta.atomikos.connectionfactory.xa-properties.password=${ACTIVEMQ_PASSWORD:}
# Настройки пула соединений для JMS
spring.jta.atomikos.connectionfactory.max-pool-size=10

# === JPA/Hibernate Configuration ===
# Hibernate должен использовать JTA
spring.jpa.properties.hibernate.transaction.jta.platform=org.hibernate.engine.transaction.jta.platform.internal.AtomikosJtaPlatform
# DDL-auto лучше оставить validate или none в продакшене, update - для разработки
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# === JMS Listener Configuration ===
# Убедимся, что слушатель транзакционный (JTA будет управлять)
# spring.jms.listener.acknowledge-mode=transacted
# Prefetch для слушателя (оптимизация)
spring.activemq.packages.trust-all=true

# Logging
logging.level.root=INFO
logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF
logging.level.org.springframework.transaction.jta=TRACE
logging.level.org.springframework.jms=DEBUG

# Включаем поддержку DLQ (по умолчанию она включена, но явно не помешает)
spring.activemq.broker.support-dlq=true
# Максимальное количество повторных доставок (например, 2 попыток после первой неудачной)
spring.activemq.redelivery-policy.maximum-redeliveries=2
# Начальная задержка перед первой повторной доставкой (в миллисекундах)
spring.activemq.redelivery-policy.initial-redelivery-delay=1000
# Использовать экспоненциальную задержку (каждая следующая задержка удваивается)
spring.activemq.redelivery-policy.use-exponential-back-off=true
# Множитель для экспоненциальной задержки
spring.activemq.redelivery-policy.back-off-multiplier=2
# Максимальная задержка между попытками (чтобы не росла бесконечно)
spring.activemq.redelivery-policy.maximum-redelivery-delay=60000
**====================================**
path: account-service/target/maven-archiver/pom.properties
contents:
artifactId=account-service
groupId=ru.sberbank.sbp.lab2
version=0.0.1-SNAPSHOT

**====================================**
path: account-service/target/surefire-reports/ru.sberbank.sbp.lab2.account_service.AccountServiceApplicationTests.txt
contents:
-------------------------------------------------------------------------------
Test set: ru.sberbank.sbp.lab2.account_service.AccountServiceApplicationTests
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.679 s -- in ru.sberbank.sbp.lab2.account_service.AccountServiceApplicationTests

**====================================**
path: account-service/HELP.md
contents:
# Read Me First
The following was discovered as part of building this project:

* The original package name 'ru.sberbank.sbp.lab2.account-service' is invalid and this project uses 'ru.sberbank.sbp.lab2.account_service' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.4.4/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.4.4/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.4.4/reference/web/servlet.html)
* [Spring Data JPA](https://docs.spring.io/spring-boot/3.4.4/reference/data/sql.html#data.sql.jpa-and-spring-data)
* [Spring for Apache ActiveMQ 5](https://docs.spring.io/spring-boot/3.4.4/reference/messaging/jms.html#messaging.jms.activemq)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)
* [Java Message Service API via Apache ActiveMQ Classic.](https://spring.io/guides/gs/messaging-jms/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


**====================================**
path: account-service/.gitignore
contents:
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

**====================================**
path: account-service/.mvn/wrapper/maven-wrapper.properties
contents:
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip

**====================================**
path: account-service/.gitattributes
contents:
/mvnw text eol=lf
*.cmd text eol=crlf

**====================================**
path: account-service/mvnw
contents:
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

**====================================**
path: account-service/src/test/java/ru/sberbank/sbp/lab2/account_service/AccountServiceApplicationTests.java
contents:
package ru.sberbank.sbp.lab2.account_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AccountServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

**====================================**
path: account-service/src/test/test.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="true" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: account-service/src/main/main3.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: account-service/src/main/resources/application.properties
contents:
# Server Configuration
server.port=8081
spring.application.name=account-service

# === Atomikos JTA Configuration ===
# Включаем JTA (хотя стартер делает это, явно не помешает)
spring.jta.enabled=true

# --- Atomikos Core Settings (опционально, можно настроить таймауты и логи) ---
spring.jta.atomikos.properties.service=com.atomikos.icatch.standalone.UserTransactionServiceFactory
# Увеличим таймаут транзакции по умолчанию (например, до 300 секунд)
spring.jta.atomikos.properties.max-timeout=300000
spring.jta.atomikos.properties.enable-logging=true
# Уровень логгирования Atomikos (WARN, INFO, DEBUG, TRACE)
# logging.level.com.atomikos=TRACE # Очень подробно, для отладки

# --- Atomikos XA DataSource Configuration (вместо spring.datasource) ---
# Уникальное имя ресурса для Atomikos (важно!)
spring.jta.atomikos.datasource.unique-resource-name=accountPostgresXA
# Класс XA DataSource для PostgreSQL
spring.jta.atomikos.datasource.xa-data-source-class-name=org.postgresql.xa.PGXADataSource
# Свойства для XA DataSource (передаются в PGXADataSource)
spring.jta.atomikos.datasource.xa-properties.user=${POSTGRES_ACCOUNT_USER:account_user}
spring.jta.atomikos.datasource.xa-properties.password=${POSTGRES_ACCOUNT_PASSWORD:your_account_password}
spring.jta.atomikos.datasource.xa-properties.url=${POSTGRES_ACCOUNT_URL:jdbc:postgresql://localhost:5432/account_db}
# Настройки пула соединений для этого DataSource (Atomikos управляет пулом)
spring.jta.atomikos.datasource.max-pool-size=10
spring.jta.atomikos.datasource.min-pool-size=2
# Запрос для проверки соединения
spring.jta.atomikos.datasource.test-query=SELECT 1

# --- Atomikos XA JMS ConnectionFactory Configuration (вместо spring.activemq) ---
# Уникальное имя ресурса для Atomikos (важно!)
spring.jta.atomikos.connectionfactory.unique-resource-name=activemqXA
# Класс XA ConnectionFactory для ActiveMQ
spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name=org.apache.activemq.ActiveMQXAConnectionFactory
# Свойства для XA ConnectionFactory
spring.jta.atomikos.connectionfactory.xa-properties.broker-url=${ACTIVEMQ_BROKER_URL:tcp://localhost:61616}
spring.jta.atomikos.connectionfactory.xa-properties.user=${ACTIVEMQ_USER:}
spring.jta.atomikos.connectionfactory.xa-properties.password=${ACTIVEMQ_PASSWORD:}
# Настройки пула соединений для JMS
spring.jta.atomikos.connectionfactory.max-pool-size=10

# === JPA/Hibernate Configuration ===
# Hibernate должен использовать JTA
spring.jpa.properties.hibernate.transaction.jta.platform=org.hibernate.engine.transaction.jta.platform.internal.AtomikosJtaPlatform
# DDL-auto лучше оставить validate или none в продакшене, update - для разработки
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# === JMS Listener Configuration ===
# Убедимся, что слушатель транзакционный (JTA будет управлять)
# spring.jms.listener.acknowledge-mode=transacted
# Prefetch для слушателя (оптимизация)
spring.activemq.packages.trust-all=true

# Logging
logging.level.root=INFO
logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF
logging.level.org.springframework.transaction.jta=TRACE
logging.level.org.springframework.jms=DEBUG

# Включаем поддержку DLQ (по умолчанию она включена, но явно не помешает)
spring.activemq.broker.support-dlq=true
# Максимальное количество повторных доставок (например, 2 попыток после первой неудачной)
spring.activemq.redelivery-policy.maximum-redeliveries=2
# Начальная задержка перед первой повторной доставкой (в миллисекундах)
spring.activemq.redelivery-policy.initial-redelivery-delay=1000
# Использовать экспоненциальную задержку (каждая следующая задержка удваивается)
spring.activemq.redelivery-policy.use-exponential-back-off=true
# Множитель для экспоненциальной задержки
spring.activemq.redelivery-policy.back-off-multiplier=2
# Максимальная задержка между попытками (чтобы не росла бесконечно)
spring.activemq.redelivery-policy.maximum-redelivery-delay=60000
**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/SendSuccessNotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import ru.sberbank.sbp.lab2.account_service.dto.NotificationCommand;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SendSuccessNotificationCommand implements NotificationCommand {

  private static final long serialVersionUID = 1L;
  private String senderPhoneNumber; // кому отправлять
  private BigDecimal amount;
  private String recipientInfo; // Инфо о получателе (номер/банк)
  private UUID correlationId;
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/SendFailureNotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SendFailureNotificationCommand implements NotificationCommand {

  private static final long serialVersionUID = 1L;
  private String senderPhoneNumber; // кому отправлять
  private BigDecimal amount;
  private String reason; // причина неудачи
  private UUID correlationId;
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/NotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.io.Serializable;
import java.util.UUID;

// Опциональный общий интерфейс для команд уведомлений
public interface NotificationCommand extends Serializable {
  UUID getCorrelationId(); // ID исходного перевода
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/SendConfirmationCodeCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SendConfirmationCodeCommand implements NotificationCommand {

  private static final long serialVersionUID = 1L;
  private String phoneNumber;
  private String code;
  private UUID correlationId;
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/CompleteTransferCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
// Здесь не нужен Builder и общий интерфейс, так как этот класс только для приема
public class CompleteTransferCommand implements Serializable {

  private static final long serialVersionUID = 1L;

  private String senderPhoneNumber;
  private String recipientPhoneNumber;
  private BigDecimal amount;
  private UUID correlationId; // ID оригинального перевода (Transfer.id)
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/ReserveFundsCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReserveFundsCommand implements Serializable { // Должен быть Serializable

  private static final long serialVersionUID = 1L;

  private String phoneNumber;
  private BigDecimal amount;
  private UUID correlationId; // ID перевода
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/dto/ReleaseFundsCommand.java
contents:
package ru.sberbank.sbp.lab2.account_service.dto;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ReleaseFundsCommand implements Serializable {

  private static final long serialVersionUID = 1L;
  private String phoneNumber;
  private BigDecimal amount;
  private UUID correlationId;
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/AccountServiceApplication.java
contents:
package ru.sberbank.sbp.lab2.account_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration;
import org.springframework.jms.annotation.EnableJms;

@SpringBootApplication(
  exclude = {
    DataSourceAutoConfiguration.class,
    DataSourceTransactionManagerAutoConfiguration.class,
    SqlInitializationAutoConfiguration.class,
  }
)
@EnableJms
public class AccountServiceApplication {

  public static void main(String[] args) {
    SpringApplication.run(AccountServiceApplication.class, args);
  }
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/repository/AccountRepository.java
contents:
package ru.sberbank.sbp.lab2.account_service.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ru.sberbank.sbp.lab2.account_service.entity.Account;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
  // Метод для поиска счета по номеру телефона
  Optional<Account> findByPhoneNumber(String phoneNumber);
  // JpaRepository уже предоставляет save, findById, findAll, deleteById и т.д.
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/config/DataSourceConfig.java
contents:
package ru.sberbank.sbp.lab2.account_service.config;

import com.atomikos.jdbc.AtomikosDataSourceBean; // Важно: это класс Atomikos
import java.util.Properties;
import javax.sql.DataSource;
import org.postgresql.xa.PGXADataSource; // Используем конкретный XADataSource
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DataSourceConfig {

  // Внедряем значения из application.properties (секция spring.jta.atomikos.datasource)
  @Value("${spring.jta.atomikos.datasource.unique-resource-name}")
  private String uniqueResourceName;

  @Value("${spring.jta.atomikos.datasource.xa-properties.url}")
  private String url;

  @Value("${spring.jta.atomikos.datasource.xa-properties.user}")
  private String user;

  @Value("${spring.jta.atomikos.datasource.xa-properties.password}")
  private String password;

  @Value("${spring.jta.atomikos.datasource.max-pool-size:10}") // Значение по умолчанию
  private int maxPoolSize;

  @Value("${spring.jta.atomikos.datasource.min-pool-size:2}") // Значение по умолчанию
  private int minPoolSize;

  @Value("${spring.jta.atomikos.datasource.test-query:SELECT 1}") // Значение по умолчанию
  private String testQuery;

  @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close")
  public DataSource dataSource() {
    // 1. Создаем реальный XA DataSource
    PGXADataSource pgXaDataSource = new PGXADataSource();
    pgXaDataSource.setUrl(url);
    pgXaDataSource.setUser(user);
    pgXaDataSource.setPassword(password);

    // 2. Оборачиваем его в AtomikosDataSourceBean
    AtomikosDataSourceBean atomikosDataSourceBean =
      new AtomikosDataSourceBean();
    atomikosDataSourceBean.setXaDataSource(pgXaDataSource);
    atomikosDataSourceBean.setUniqueResourceName(uniqueResourceName);
    atomikosDataSourceBean.setMaxPoolSize(maxPoolSize);
    atomikosDataSourceBean.setMinPoolSize(minPoolSize);
    atomikosDataSourceBean.setTestQuery(testQuery);
    // atomikosDataSourceBean.setBorrowConnectionTimeout(60); // Таймаут ожидания соединения из пула (сек)
    // atomikosDataSourceBean.setReapTimeout(0); // Таймаут для "мертвых" соединений (0 - отключено)
    // atomikosDataSourceBean.setMaxIdleTime(60); // Время простоя перед удалением из пула

    System.out.println("Initializing AtomikosDataSourceBean with URL: " + url); // Отладочный вывод

    return atomikosDataSourceBean;
  }
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/entity/Account.java
contents:
package ru.sberbank.sbp.lab2.account_service.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import java.math.BigDecimal;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "accounts") // Явно укажем имя таблицы
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Account {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY) // Используем автоинкремент БД
  private Long id;

  @NotBlank(message = "Phone number is mandatory")
  @Pattern(regexp = "\\d{10}", message = "Phone number must be 10 digits")
  @Column(nullable = false, unique = true, length = 10) // Номер телефона - уникальный ключ
  private String phoneNumber;

  @NotNull(message = "Balance cannot be null")
  @DecimalMin(value = "0.00", message = "Balance cannot be negative")
  @Column(nullable = false, precision = 19, scale = 2) // Тип для денег
  private BigDecimal balance;

  @NotNull(message = "Reserved amount cannot be null")
  @DecimalMin(value = "0.00", message = "Reserved amount cannot be negative")
  @Column(nullable = false, precision = 19, scale = 2)
  private BigDecimal reservedAmount;

  @Version // Для оптимистичной блокировки
  private Long version;

  // Инициализация полей по умолчанию в конструкторе без аргументов
  public Account(String phoneNumber) {
    this.phoneNumber = phoneNumber;
    this.balance = BigDecimal.ZERO;
    this.reservedAmount = BigDecimal.ZERO;
  }
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/service/AccountService.java
contents:
package ru.sberbank.sbp.lab2.account_service.service;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.UUID;
import ru.sberbank.sbp.lab2.account_service.entity.Account;

public interface AccountService {
  /**
   * Проверяет, достаточно ли средств на счете (баланс минус резерв).
   * @param phoneNumber Номер телефона.
   * @param amount Сумма для проверки.
   * @return true, если средств достаточно, иначе false.
   * @throws ru.sberbank.sbp.lab2.account.exception.AccountNotFoundException если счет не найден.
   */
  boolean hasEnoughBalance(String phoneNumber, BigDecimal amount);

  /**
   * Резервирует средства на счете.
   * Увеличивает reservedAmount.
   * @param phoneNumber Номер телефона.
   * @param amount Сумма для резервирования.
   * @throws ru.sberbank.sbp.lab2.account.exception.AccountNotFoundException если счет не найден.
   * @throws ru.sberbank.sbp.lab2.account.exception.InsufficientFundsException если недостаточно средств.
   */
  void reserveFunds(String phoneNumber, BigDecimal amount);

  /**
   * Освобождает ранее зарезервированные средства (используется при отмене перевода).
   * Уменьшает reservedAmount. Не должен падать, если счет не найден.
   * @param phoneNumber Номер телефона.
   * @param amount Сумма для освобождения.
   * @param correlationId ID оригинального перевода для логирования.
   */
  void releaseFunds(String phoneNumber, BigDecimal amount, UUID correlationId);

  /**
   * Завершает перевод: списывает средства с баланса отправителя
   * (уменьшает balance и reservedAmount) и зачисляет на баланс получателя.
   * Этот метод должен быть атомарным для обоих счетов.
   * @param senderPhoneNumber Номер телефона отправителя.
   * @param recipientPhoneNumber Номер телефона получателя.
   * @param amount Сумма перевода.
   * @param correlationId ID оригинального перевода для логирования.
   * @throws ru.sberbank.sbp.lab2.account_service.exception.AccountNotFoundException если счет отправителя не найден.
   * @throws IllegalStateException если зарезервированная сумма отправителя меньше суммы перевода.
   * @throws RuntimeException при других ошибках (например, проблема с созданием счета получателя).
   */
  void completeTransfer(
    String senderPhoneNumber,
    String recipientPhoneNumber,
    BigDecimal amount,
    UUID correlationId
  );

  /**
   * Получает текущий баланс счета.
   * @param phoneNumber Номер телефона.
   * @return Текущий баланс.
   * @throws ru.sberbank.sbp.lab2.account.exception.AccountNotFoundException если счет не найден.
   */
  BigDecimal getBalance(String phoneNumber);

  /**
   * Получает текущую зарезервированную сумму.
   * @param phoneNumber Номер телефона.
   * @return Зарезервированная сумма.
   * @throws ru.sberbank.sbp.lab2.account.exception.AccountNotFoundException если счет не найден.
   */
  BigDecimal getReservedAmount(String phoneNumber);
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/service/AccountServiceImpl.java
contents:
package ru.sberbank.sbp.lab2.account_service.service;

import jakarta.transaction.Transactional;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.Optional;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Propagation;
import ru.sberbank.sbp.lab2.account_service.entity.Account;
import ru.sberbank.sbp.lab2.account_service.exception.AccountNotFoundException;
import ru.sberbank.sbp.lab2.account_service.exception.InsufficientFundsException;
import ru.sberbank.sbp.lab2.account_service.repository.AccountRepository;

@Service
@RequiredArgsConstructor
@Slf4j
public class AccountServiceImpl implements AccountService {

  private final AccountRepository accountRepository;

  // Проверка баланса - операция чтения
  @Override
  @Transactional
  public boolean hasEnoughBalance(String phoneNumber, BigDecimal amount) {
    log.debug("Checking balance for {} amount {}", phoneNumber, amount);
    Account account = getAccountByPhoneNumber(phoneNumber);
    // Доступный баланс = Общий баланс - Зарезервированная сумма
    BigDecimal availableBalance = account
      .getBalance()
      .subtract(account.getReservedAmount());
    boolean enough = availableBalance.compareTo(amount) >= 0;
    log.debug(
      "Available balance for {}: {}. Enough: {}",
      phoneNumber,
      availableBalance,
      enough
    );
    return enough;
  }

  // Резервирование средств - операция записи
  @Override
  @Transactional
  public void reserveFunds(String phoneNumber, BigDecimal amount) {
    log.info("Reserving funds {} for phone number: {}", amount, phoneNumber);
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      throw new IllegalArgumentException("Cannot reserve negative amount");
    }
    Account account = getAccountByPhoneNumber(phoneNumber);

    if (!hasEnoughBalance(phoneNumber, amount)) {
      log.warn("Insufficient funds for phone number: {}", phoneNumber);
      throw new InsufficientFundsException(
        "Insufficient funds for phone number: " + phoneNumber
      );
    }

    account.setReservedAmount(account.getReservedAmount().add(amount));
    accountRepository.save(account); // Сохраняем изменения
    log.info(
      "Funds reserved successfully for {}. New reserved amount: {}",
      phoneNumber,
      account.getReservedAmount()
    );
  }

  // Только для внутреннего использования
  @Transactional
  protected void releaseReservedFundsInternal(
    String phoneNumber,
    BigDecimal amount
  ) {
    Account account = getAccountByPhoneNumber(phoneNumber);
    BigDecimal newReserved = account.getReservedAmount().subtract(amount);
    if (newReserved.compareTo(BigDecimal.ZERO) < 0) {
      log.error(
        "Attempted to release more funds ({}) than reserved ({}) for {}",
        amount,
        account.getReservedAmount(),
        phoneNumber
      );
      newReserved = BigDecimal.ZERO;
    }
    account.setReservedAmount(newReserved);
    // Не сохраняем здесь, сохранение будет в вызывающем методе (completeTransfer)
    log.info(
      "Internal releaseReservedFunds: New reserved amount for {}: {}",
      phoneNumber,
      newReserved
    );
  }

  @Override
  @Transactional // Участвует в JTA транзакции слушателя
  public void releaseFunds(
    String phoneNumber,
    BigDecimal amount,
    UUID correlationId
  ) {
    log.info(
      "[CorrelationId: {}] Releasing reserved funds {} for phone number: {}",
      correlationId,
      amount,
      phoneNumber
    );
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      // Можно просто залогировать и выйти, т.к. это не ошибка бизнес-процесса
      log.warn(
        "[CorrelationId: {}] Cannot release negative amount: {}",
        correlationId,
        amount
      );
      return;
    }

    try {
      Account account = getAccountByPhoneNumber(phoneNumber); // Ищем счет

      BigDecimal newReserved = account.getReservedAmount().subtract(amount);
      if (newReserved.compareTo(BigDecimal.ZERO) < 0) {
        log.warn(
          // Логируем как WARN, т.к. это может быть при повторной обработке
          "[CorrelationId: {}] Attempted to release more funds ({}) than reserved ({}) for {}. Setting reserved to 0.",
          correlationId,
          amount,
          account.getReservedAmount(),
          phoneNumber
        );
        newReserved = BigDecimal.ZERO;
      }
      account.setReservedAmount(newReserved);
      accountRepository.save(account); // Сохраняем изменения
      log.info(
        "[CorrelationId: {}] Reserved funds released successfully for {}. New reserved amount: {}",
        correlationId,
        phoneNumber,
        account.getReservedAmount()
      );
    } catch (AccountNotFoundException e) {
      // Если счет не найден - это нормально в этом сценарии (возможно, резерв и не создавался).
      // Просто логируем и НЕ бросаем исключение дальше, чтобы JTA закоммитила транзакцию JMS.
      log.warn(
        "[CorrelationId: {}] Account not found while trying to release funds for phone number: {}. Assuming reservation was not made or already cancelled.",
        correlationId,
        phoneNumber
      );
    }
    // Другие RuntimeException будут пойманы и обработаны в слушателе
  }

  @Override
  @Transactional
  public void completeTransfer(
    String senderPhoneNumber,
    String recipientPhoneNumber,
    BigDecimal amount,
    UUID correlationId
  ) {
    log.info(
      "[CorrelationId: {}] Completing transfer of {} from {} to {}",
      correlationId,
      amount,
      senderPhoneNumber,
      recipientPhoneNumber
    );
    if (amount.compareTo(BigDecimal.ZERO) < 0) {
      throw new IllegalArgumentException("Cannot transfer negative amount");
    }

    // 1. Найти счет отправителя (он должен существовать)
    Account senderAccount = getAccountByPhoneNumber(senderPhoneNumber);

    // 2. Проверить зарезервированную сумму отправителя
    // Эта проверка остается важной на случай гонки или неконсистентности
    if (senderAccount.getReservedAmount().compareTo(amount) < 0) {
      log.error(
        "[CorrelationId: {}] Attempt to complete transfer for sender {}, but reserved amount {} is less than transfer amount {}",
        correlationId,
        senderPhoneNumber,
        senderAccount.getReservedAmount(),
        amount
      );
      throw new IllegalStateException(
        "Cannot complete transfer, inconsistent reserved amount for sender: " +
        senderPhoneNumber
      );
    }

    // 3. Найти счет получателя (он ТОЖЕ должен существовать)
    Account recipientAccount = getAccountByPhoneNumber(recipientPhoneNumber);

    // 4. Выполнить дебет отправителя
    // Сначала вызываем внутренний метод для уменьшения резерва (без сохранения)
    releaseReservedFundsInternal(senderPhoneNumber, amount);
    // Затем уменьшаем баланс
    senderAccount.setBalance(senderAccount.getBalance().subtract(amount));
    log.info(
      "[CorrelationId: {}] Debited amount {} from sender {}. New balance: {}, New reserved: {}",
      correlationId,
      amount,
      senderPhoneNumber,
      senderAccount.getBalance(),
      senderAccount.getReservedAmount()
    );

    // 5. Выполнить кредит получателя
    recipientAccount.setBalance(recipientAccount.getBalance().add(amount));
    log.info(
      "[CorrelationId: {}] Credited amount {} to recipient {}. New balance: {}",
      correlationId,
      amount,
      recipientPhoneNumber,
      recipientAccount.getBalance()
    );

    // 6. Сохранить оба измененных счета АТОМАРНО
    // Передаем обновленные объекты senderAccount и recipientAccount
    accountRepository.saveAll(Arrays.asList(senderAccount, recipientAccount));
    log.info(
      "[CorrelationId: {}] Successfully saved changes for sender {} and recipient {}",
      correlationId,
      senderPhoneNumber,
      recipientPhoneNumber
    );
  }

  @Override
  @Transactional
  public BigDecimal getBalance(String phoneNumber) {
    return getAccountByPhoneNumber(phoneNumber).getBalance();
  }

  @Override
  @Transactional
  public BigDecimal getReservedAmount(String phoneNumber) {
    return getAccountByPhoneNumber(phoneNumber).getReservedAmount();
  }

  // Вспомогательный приватный метод для получения счета
  private Account getAccountByPhoneNumber(String phoneNumber) {
    return accountRepository
      .findByPhoneNumber(phoneNumber)
      .orElseThrow(() -> {
        log.warn("Account not found for phone number: {}", phoneNumber);
        return new AccountNotFoundException(
          "Account not found for phone number: " + phoneNumber
        );
      });
  }
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/jms/JmsConfig.java
contents:
package ru.sberbank.sbp.lab2.account_service.jms;

public final class JmsConfig { // Используем final класс без конструктора

  private JmsConfig() { // Приватный конструктор, чтобы нельзя было создать экземпляр
  }

  // --- Account Service Queues ---
  public static final String ACCOUNT_RESERVE_FUNDS_QUEUE =
    "account.command.reserve.queue";
  public static final String ACCOUNT_COMPLETE_TRANSFER_QUEUE =
    "account.command.complete.queue";
  public static final String ACCOUNT_RELEASE_FUNDS_QUEUE =
    "account.command.release.queue";

  // --- Notification Service Queues ---
  public static final String NOTIFICATION_SEND_CODE_QUEUE =
    "notification.command.sendcode.queue";
  public static final String NOTIFICATION_SEND_SUCCESS_QUEUE =
    "notification.command.sendsuccess.queue";
  public static final String NOTIFICATION_SEND_FAILURE_QUEUE =
    "notification.command.sendfailure.queue";
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/jms/AccountCommandListener.java
contents:
package ru.sberbank.sbp.lab2.account_service.jms;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;
import ru.sberbank.sbp.lab2.account_service.dto.CompleteTransferCommand;
import ru.sberbank.sbp.lab2.account_service.dto.ReleaseFundsCommand;
import ru.sberbank.sbp.lab2.account_service.dto.ReserveFundsCommand;
import ru.sberbank.sbp.lab2.account_service.exception.AccountNotFoundException;
import ru.sberbank.sbp.lab2.account_service.exception.InsufficientFundsException;
import ru.sberbank.sbp.lab2.account_service.service.AccountService;

@Component
@RequiredArgsConstructor
@Slf4j
public class AccountCommandListener {

  private final AccountService accountService;

  @JmsListener(
    destination = JmsConfig.ACCOUNT_RESERVE_FUNDS_QUEUE,
    containerFactory = "jmsListenerContainerFactory"
  )
  public void handleReserveFundsCommand(@Payload ReserveFundsCommand command) {
    log.info(
      "Received and converted JMS message on queue '{}': {}",
      JmsConfig.ACCOUNT_RESERVE_FUNDS_QUEUE,
      command
    );
    try {
      accountService.reserveFunds(
        command.getPhoneNumber(),
        command.getAmount()
      );
      log.info(
        "Successfully processed ReserveFundsCommand with correlationId: {}",
        command.getCorrelationId()
      );
    } catch (AccountNotFoundException | InsufficientFundsException e) {
      log.warn(
        "Business error processing ReserveFundsCommand with correlationId: {}. Reason: {}",
        command.getCorrelationId(),
        e.getMessage()
      );
      throw new RuntimeException(
        "Business error processing command " + command.getCorrelationId(),
        e
      );
    } catch (Exception e) {
      log.error(
        "Unexpected error processing ReserveFundsCommand with correlationId: {}. Error: {}",
        command.getCorrelationId(),
        e.getMessage(),
        e
      );
      throw new RuntimeException(
        "Unexpected error processing command " + command.getCorrelationId(),
        e
      );
    }
  }

  @JmsListener(
    destination = JmsConfig.ACCOUNT_COMPLETE_TRANSFER_QUEUE,
    containerFactory = "jmsListenerContainerFactory"
  )
  public void handleCompleteTransferCommand(
    @Payload CompleteTransferCommand command
  ) {
    log.info(
      "Received and converted JMS message on queue '{}': {}",
      JmsConfig.ACCOUNT_COMPLETE_TRANSFER_QUEUE,
      command
    );
    try {
      // Вызываем новый метод сервиса для завершения перевода
      accountService.completeTransfer(
        command.getSenderPhoneNumber(),
        command.getRecipientPhoneNumber(),
        command.getAmount(),
        command.getCorrelationId() // Передаем ID для логов/отслеживания
      );
      log.info(
        "Successfully processed CompleteTransferCommand with correlationId: {}",
        command.getCorrelationId()
      );
    } catch (
      AccountNotFoundException
      | InsufficientFundsException
      | IllegalStateException e
    ) {
      // IllegalStateException может быть из проверки резерва
      log.warn(
        "Business error processing CompleteTransferCommand with correlationId: {}. Reason: {}",
        command.getCorrelationId(),
        e.getMessage()
      );
      // Откатываем транзакцию
      throw new RuntimeException(
        "Business error processing command " + command.getCorrelationId(),
        e
      );
    } catch (Exception e) {
      log.error(
        "Unexpected error processing CompleteTransferCommand with correlationId: {}. Error: {}",
        command.getCorrelationId(),
        e.getMessage(),
        e
      );
      // Откатываем транзакцию
      throw new RuntimeException(
        "Unexpected error processing command " + command.getCorrelationId(),
        e
      );
    }
  }

  @JmsListener(
    destination = JmsConfig.ACCOUNT_RELEASE_FUNDS_QUEUE,
    containerFactory = "jmsListenerContainerFactory"
  )
  public void handleReleaseFundsCommand(@Payload ReleaseFundsCommand command) {
    log.info(
      "Received and converted JMS message on queue '{}': {}",
      JmsConfig.ACCOUNT_RELEASE_FUNDS_QUEUE,
      command
    );
    try {
      accountService.releaseFunds(
        command.getPhoneNumber(),
        command.getAmount(),
        command.getCorrelationId()
      );
      log.info(
        "Successfully processed ReleaseFundsCommand with correlationId: {}",
        command.getCorrelationId()
      );
    } catch (AccountNotFoundException e) {
      // Важно: Что делать, если счет не найден при попытке отменить резерв?
      // Вероятно, это ошибка, но не критичная для отката. Просто логируем.
      log.warn(
        "Account not found while processing ReleaseFundsCommand with correlationId: {}. Reason: {}",
        command.getCorrelationId(),
        e.getMessage()
      );
      // Не бросаем исключение, чтобы JTA закоммитила транзакцию (сообщение будет удалено)
    } catch (Exception e) {
      log.error(
        "Unexpected error processing ReleaseFundsCommand with correlationId: {}. Error: {}",
        command.getCorrelationId(),
        e.getMessage(),
        e
      );
      // Откатываем транзакцию при неожиданных ошибках
      throw new RuntimeException(
        "Unexpected error processing command " + command.getCorrelationId(),
        e
      );
    }
  }
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/jms/JmsConverterConfig.java
contents:
package ru.sberbank.sbp.lab2.account_service.jms;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.jms.ConnectionFactory;
import java.util.HashMap;
import java.util.Map;
import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.springframework.jms.config.JmsListenerContainerFactory;
import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessageType;
import ru.sberbank.sbp.lab2.account_service.dto.CompleteTransferCommand;
import ru.sberbank.sbp.lab2.account_service.dto.ReleaseFundsCommand;
import ru.sberbank.sbp.lab2.account_service.dto.ReserveFundsCommand;

@Configuration
public class JmsConverterConfig {

  @Bean
  public ObjectMapper objectMapper() {
    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    return mapper;
  }

  @Bean
  public MessageConverter jacksonJmsMessageConverter(
    ObjectMapper objectMapper
  ) {
    MappingJackson2MessageConverter converter =
      new MappingJackson2MessageConverter();
    converter.setTargetType(MessageType.TEXT);
    converter.setTypeIdPropertyName("_type");
    converter.setObjectMapper(objectMapper);

    Map<String, Class<?>> typeIdMappings = new HashMap<>();
    // Маппинг для ReserveFundsCommand
    typeIdMappings.put(
      "ru.sberbank.sbp.lab2.transfer_service.dto.jms.ReserveFundsCommand",
      ReserveFundsCommand.class
    );
    // Маппинг для CompleteTransferCommand
    typeIdMappings.put(
      "ru.sberbank.sbp.lab2.transfer_service.dto.jms.CompleteTransferCommand",
      CompleteTransferCommand.class
    );
    // Маппинг для ReleaseFundsCommand
    typeIdMappings.put(
      "ru.sberbank.sbp.lab2.transfer_service.dto.jms.ReleaseFundsCommand",
      ReleaseFundsCommand.class
    );

    converter.setTypeIdMappings(typeIdMappings);

    return converter;
  }

  @Bean // Фабрика слушателей
  public JmsListenerContainerFactory<?> jmsListenerContainerFactory(
    ConnectionFactory connectionFactory,
    DefaultJmsListenerContainerFactoryConfigurer configurer,
    MessageConverter messageConverter,
    org.springframework.transaction.PlatformTransactionManager transactionManager
  ) {
    DefaultJmsListenerContainerFactory factory =
      new DefaultJmsListenerContainerFactory();
    configurer.configure(factory, connectionFactory);
    factory.setMessageConverter(messageConverter);
    factory.setTransactionManager(transactionManager);
    factory.setSessionTransacted(true);
    return factory;
  }
}

**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/exception/InsufficientFundsException.java
contents:
package ru.sberbank.sbp.lab2.account_service.exception;

public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}
**====================================**
path: account-service/src/main/java/ru/sberbank/sbp/lab2/account_service/exception/AccountNotFoundException.java
contents:
package ru.sberbank.sbp.lab2.account_service.exception;

public class AccountNotFoundException extends RuntimeException {
    public AccountNotFoundException(String message) {
        super(message);
    }
}
**====================================**
path: notification-service/target/classes/application.properties
contents:
# Server Configuration
server.port=8082
spring.application.name=notification-service

# ActiveMQ Configuration (Standard, non-XA)
spring.activemq.broker-url=tcp://localhost:61616
# spring.activemq.user=admin # Если есть аутентификация
# spring.activemq.password=admin # Если есть аутентификация
spring.activemq.pool.enabled=true
# Важно для десериализации DTO из другого пакета
spring.activemq.packages.trust-all=true
# Если не используем trust-all, нужно перечислить доверенные пакеты:
# spring.activemq.packages.trusted=ru.sberbank.sbp.lab2.transfer_service.dto.jms,java.util,java.lang,java.math

# JMS Listener Configuration (Standard non-JTA)
# Режим подтверждения: AUTO - брокер считает сообщение доставленным после вызова listener'а (даже если упал)
# Лучше CLIENT - подтверждение после успешного выполнения метода listener'а
# Но для простой заглушки AUTO достаточно.
spring.jms.listener.acknowledge-mode=auto
# spring.jms.listener.concurrency=5 # Можно настроить количество потоков слушателя

# Logging
logging.level.root=INFO
logging.level.ru.sberbank.sbp.lab2.notification_service=DEBUG
logging.level.org.springframework.jms=DEBUG
**====================================**
path: notification-service/HELP.md
contents:
# Read Me First
The following was discovered as part of building this project:

* The original package name 'ru.sberbank.sbp.lab2.notification-service' is invalid and this project uses 'ru.sberbank.sbp.lab2.notification_service' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.4.4/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.4.4/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.4.4/reference/web/servlet.html)
* [Spring for Apache ActiveMQ 5](https://docs.spring.io/spring-boot/3.4.4/reference/messaging/jms.html#messaging.jms.activemq)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Java Message Service API via Apache ActiveMQ Classic.](https://spring.io/guides/gs/messaging-jms/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


**====================================**
path: notification-service/.gitignore
contents:
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

**====================================**
path: notification-service/.mvn/wrapper/maven-wrapper.properties
contents:
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip

**====================================**
path: notification-service/.gitattributes
contents:
/mvnw text eol=lf
*.cmd text eol=crlf

**====================================**
path: notification-service/mvnw
contents:
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

**====================================**
path: notification-service/src/test/test3.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="true" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: notification-service/src/test/java/ru/sberbank/sbp/lab2/notification_service/NotificationServiceApplicationTests.java
contents:
package ru.sberbank.sbp.lab2.notification_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class NotificationServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

**====================================**
path: notification-service/src/main/main4.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: notification-service/src/main/resources/application.properties
contents:
# Server Configuration
server.port=8082
spring.application.name=notification-service

# ActiveMQ Configuration (Standard, non-XA)
spring.activemq.broker-url=tcp://localhost:61616
# spring.activemq.user=admin # Если есть аутентификация
# spring.activemq.password=admin # Если есть аутентификация
spring.activemq.pool.enabled=true
# Важно для десериализации DTO из другого пакета
spring.activemq.packages.trust-all=true
# Если не используем trust-all, нужно перечислить доверенные пакеты:
# spring.activemq.packages.trusted=ru.sberbank.sbp.lab2.transfer_service.dto.jms,java.util,java.lang,java.math

# JMS Listener Configuration (Standard non-JTA)
# Режим подтверждения: AUTO - брокер считает сообщение доставленным после вызова listener'а (даже если упал)
# Лучше CLIENT - подтверждение после успешного выполнения метода listener'а
# Но для простой заглушки AUTO достаточно.
spring.jms.listener.acknowledge-mode=auto
# spring.jms.listener.concurrency=5 # Можно настроить количество потоков слушателя

# Logging
logging.level.root=INFO
logging.level.ru.sberbank.sbp.lab2.notification_service=DEBUG
logging.level.org.springframework.jms=DEBUG
**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/dto/SendSuccessNotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.notification_service.dto;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SendSuccessNotificationCommand implements Serializable {

  private static final long serialVersionUID = 1L;
  private String senderPhoneNumber;
  private BigDecimal amount;
  private String recipientInfo;
  private UUID correlationId;
}

**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/dto/SendFailureNotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.notification_service.dto;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SendFailureNotificationCommand implements Serializable {

  private static final long serialVersionUID = 1L;
  private String senderPhoneNumber;
  private BigDecimal amount;
  private String reason;
  private UUID correlationId;
}

**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/dto/SendConfirmationCodeCommand.java
contents:
package ru.sberbank.sbp.lab2.notification_service.dto;

import java.io.Serializable;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SendConfirmationCodeCommand implements Serializable {

  private static final long serialVersionUID = 1L;
  private String phoneNumber;
  private String code;
  private UUID correlationId;
}

**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/NotificationServiceApplication.java
contents:
package ru.sberbank.sbp.lab2.notification_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;
import org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration;
import org.springframework.jms.annotation.EnableJms;

@SpringBootApplication(
  exclude = {
    DataSourceAutoConfiguration.class,
    DataSourceTransactionManagerAutoConfiguration.class,
    HibernateJpaAutoConfiguration.class,
    SqlInitializationAutoConfiguration.class,
  }
)
@EnableJms
public class NotificationServiceApplication {

  public static void main(String[] args) {
    SpringApplication.run(NotificationServiceApplication.class, args);
  }
}

**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/jms/JmsConfig.java
contents:
package ru.sberbank.sbp.lab2.notification_service.jms;

public final class JmsConfig {

  private JmsConfig() {}

  // Очереди, которые СЛУШАЕТ этот сервис
  public static final String NOTIFICATION_SEND_CODE_QUEUE =
    "notification.command.sendcode.queue";
  public static final String NOTIFICATION_SEND_SUCCESS_QUEUE =
    "notification.command.sendsuccess.queue";
  public static final String NOTIFICATION_SEND_FAILURE_QUEUE =
    "notification.command.sendfailure.queue";
  // Имена очередей account service здесь не нужны
}

**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/jms/NotificationCommandListener.java
contents:
package ru.sberbank.sbp.lab2.notification_service.jms;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;
import ru.sberbank.sbp.lab2.notification_service.dto.SendConfirmationCodeCommand;
import ru.sberbank.sbp.lab2.notification_service.dto.SendFailureNotificationCommand;
import ru.sberbank.sbp.lab2.notification_service.dto.SendSuccessNotificationCommand;

@Component
@RequiredArgsConstructor
@Slf4j
public class NotificationCommandListener {

  @JmsListener(
    destination = JmsConfig.NOTIFICATION_SEND_CODE_QUEUE,
    containerFactory = "jmsListenerContainerFactory"
  )
  public void handleSendCode(@Payload SendConfirmationCodeCommand command) {
    log.info("Received SendConfirmationCodeCommand: {}", command);
    // TODO: Имитация отправки кода
    log.info(
      "PRETENDING TO SEND CODE {} to {}",
      command.getCode(),
      command.getPhoneNumber()
    );
  }

  @JmsListener(
    destination = JmsConfig.NOTIFICATION_SEND_SUCCESS_QUEUE,
    containerFactory = "jmsListenerContainerFactory"
  )
  public void handleSendSuccess(
    @Payload SendSuccessNotificationCommand command
  ) {
    log.info("Received SendSuccessNotificationCommand: {}", command);
    // TODO: Имитация отправки уведомления об успехе
    log.info(
      "PRETENDING TO SEND SUCCESS notification to {}",
      command.getSenderPhoneNumber()
    );
  }

  @JmsListener(
    destination = JmsConfig.NOTIFICATION_SEND_FAILURE_QUEUE,
    containerFactory = "jmsListenerContainerFactory"
  )
  public void handleSendFailure(
    @Payload SendFailureNotificationCommand command
  ) {
    log.info("Received SendFailureNotificationCommand: {}", command);
    // TODO: Имитация отправки уведомления об ошибке
    log.info(
      "PRETENDING TO SEND FAILURE notification to {} (reason: {})",
      command.getSenderPhoneNumber(),
      command.getReason()
    );
  }
}

**====================================**
path: notification-service/src/main/java/ru/sberbank/sbp/lab2/notification_service/jms/JmsConverterConfig.java
contents:
package ru.sberbank.sbp.lab2.notification_service.jms;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.jms.ConnectionFactory;
import java.util.HashMap;
import java.util.Map;
// Импорт ActiveMQConnectionFactory
import org.apache.activemq.ActiveMQConnectionFactory;
// Импорт Value для чтения properties
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.springframework.jms.config.JmsListenerContainerFactory;
import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessageType;
// Импорты ЛОКАЛЬНЫХ DTO
import ru.sberbank.sbp.lab2.notification_service.dto.SendConfirmationCodeCommand;
import ru.sberbank.sbp.lab2.notification_service.dto.SendFailureNotificationCommand;
import ru.sberbank.sbp.lab2.notification_service.dto.SendSuccessNotificationCommand;

@Configuration
public class JmsConverterConfig {

  @Value("${spring.activemq.broker-url:tcp://localhost:61616}")
  private String brokerUrl;

  @Value("${spring.activemq.user:#{null}}")
  private String user;

  @Value("${spring.activemq.password:#{null}}")
  private String password;

  // Создаем обычную (не XA) ConnectionFactory
  @Bean
  public ConnectionFactory connectionFactory() {
    ActiveMQConnectionFactory activeMQConnectionFactory =
      new ActiveMQConnectionFactory();
    activeMQConnectionFactory.setBrokerURL(brokerUrl);
    if (user != null && !user.isEmpty() && password != null) {
      activeMQConnectionFactory.setUserName(user);
      activeMQConnectionFactory.setPassword(password);
    }
    // Важно для десериализации DTO из другого пакета (если spring.activemq.packages.trust-all=false)
    // activeMQConnectionFactory.setTrustedPackages(Arrays.asList("ru.sberbank.sbp.lab2.transfer_service.dto.jms", "java.util", "java.lang", "java.math"));
    activeMQConnectionFactory.setTrustAllPackages(true); // Проще для ЛР
    return activeMQConnectionFactory;
    // Можно обернуть в CachingConnectionFactory для производительности,
    // но Spring Boot с включенным пулом (spring.activemq.pool.enabled=true) делает это сам.
    // CachingConnectionFactory cachingFactory = new CachingConnectionFactory(activeMQConnectionFactory);
    // return cachingFactory;
  }

  @Bean
  public ObjectMapper objectMapper() {
    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    return mapper;
  }

  @Bean
  public MessageConverter jacksonJmsMessageConverter(
    ObjectMapper objectMapper
  ) {
    MappingJackson2MessageConverter converter =
      new MappingJackson2MessageConverter();
    converter.setTargetType(MessageType.TEXT);
    converter.setTypeIdPropertyName("_type");
    converter.setObjectMapper(objectMapper);

    Map<String, Class<?>> typeIdMappings = new HashMap<>();
    typeIdMappings.put(
      "ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendConfirmationCodeCommand",
      SendConfirmationCodeCommand.class
    );
    typeIdMappings.put(
      "ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendSuccessNotificationCommand",
      SendSuccessNotificationCommand.class
    );
    typeIdMappings.put(
      "ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendFailureNotificationCommand",
      SendFailureNotificationCommand.class
    );
    converter.setTypeIdMappings(typeIdMappings);

    return converter;
  }

  // Фабрика для слушателей (НЕ JTA)
  @Bean
  public JmsListenerContainerFactory<?> jmsListenerContainerFactory(
    ConnectionFactory connectionFactory,
    DefaultJmsListenerContainerFactoryConfigurer configurer,
    MessageConverter messageConverter
  ) {
    DefaultJmsListenerContainerFactory factory =
      new DefaultJmsListenerContainerFactory();
    configurer.configure(factory, connectionFactory);
    factory.setMessageConverter(messageConverter);
    return factory;
  }
}

**====================================**
path: sbp-adapter-service/target/classes/application.properties
contents:
server.port=8083
spring.application.name=sbp-adapter-service

logging.level.root=INFO
logging.level.ru.sberbank.sbp.lab2.sbp_adapter_service=DEBUG
**====================================**
path: sbp-adapter-service/target/maven-archiver/pom.properties
contents:
artifactId=sbp-adapter-service
groupId=ru.sberbank.sbp.lab2
version=1.0.0-SNAPSHOT

**====================================**
path: sbp-adapter-service/target/surefire-reports/ru.sberbank.sbp.lab2.sbp_adapter_service.SbpAdapterServiceApplicationTests.txt
contents:
-------------------------------------------------------------------------------
Test set: ru.sberbank.sbp.lab2.sbp_adapter_service.SbpAdapterServiceApplicationTests
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.858 s -- in ru.sberbank.sbp.lab2.sbp_adapter_service.SbpAdapterServiceApplicationTests

**====================================**
path: sbp-adapter-service/HELP.md
contents:
# Read Me First
The following was discovered as part of building this project:

* The original package name 'ru.sberbank.sbp.lab2.sbp-adapter-service' is invalid and this project uses 'ru.sberbank.sbp.lab2.sbp_adapter_service' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.4.4/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.4.4/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.4.4/reference/web/servlet.html)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


**====================================**
path: sbp-adapter-service/.gitignore
contents:
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

**====================================**
path: sbp-adapter-service/.mvn/wrapper/maven-wrapper.properties
contents:
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip

**====================================**
path: sbp-adapter-service/.gitattributes
contents:
/mvnw text eol=lf
*.cmd text eol=crlf

**====================================**
path: sbp-adapter-service/mvnw
contents:
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

**====================================**
path: sbp-adapter-service/src/test/test4.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="true" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: sbp-adapter-service/src/test/java/ru/sberbank/sbp/lab2/sbp_adapter_service/SbpAdapterServiceApplicationTests.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SbpAdapterServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

**====================================**
path: sbp-adapter-service/src/main/resources/application.properties
contents:
server.port=8083
spring.application.name=sbp-adapter-service

logging.level.root=INFO
logging.level.ru.sberbank.sbp.lab2.sbp_adapter_service=DEBUG
**====================================**
path: sbp-adapter-service/src/main/main.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/dto/SbpTransferRequest.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import java.math.BigDecimal;
import java.util.UUID;
import lombok.Data;

@Data
public class SbpTransferRequest {

  @NotBlank
  @Pattern(regexp = "\\d{10}")
  private String senderPhoneNumber;

  @NotBlank
  @Pattern(regexp = "\\d{10}")
  private String recipientPhoneNumber;

  @NotNull
  @DecimalMin("0.01")
  private BigDecimal amount;

  @NotNull
  private UUID correlationId; // ID из transfer-service
}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/dto/SbpTransferResponse.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SbpTransferResponse {

  private boolean success;
  private String sbpTransactionId; // ID операции в "СБП"
  private String errorMessage;
}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/dto/BankInfo.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class BankInfo {

  private String bankId;
  private String bankName;
  private boolean supportsSbp;
}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/controller/SbpAdapterController.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.controller;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import java.util.Optional;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import ru.sberbank.sbp.lab2.sbp_adapter_service.dto.BankInfo;
import ru.sberbank.sbp.lab2.sbp_adapter_service.dto.SbpTransferRequest;
import ru.sberbank.sbp.lab2.sbp_adapter_service.dto.SbpTransferResponse;
import ru.sberbank.sbp.lab2.sbp_adapter_service.exception.SbpBusinessException;
import ru.sberbank.sbp.lab2.sbp_adapter_service.exception.SbpTechnicalException;
import ru.sberbank.sbp.lab2.sbp_adapter_service.service.SbpAdapterLogic;

@RestController
@RequestMapping("/api/sbp")
@RequiredArgsConstructor
@Validated
public class SbpAdapterController {

  private final SbpAdapterLogic sbpAdapterLogic;

  @GetMapping("/banks")
  public ResponseEntity<BankInfo> findBankByPhoneNumber(
    @RequestParam @NotBlank @Pattern(regexp = "\\d{10}") String phoneNumber
  ) {
    Optional<BankInfo> bankInfoOptional = sbpAdapterLogic.findBank(phoneNumber);
    return bankInfoOptional
      .map(ResponseEntity::ok)
      .orElseGet(() -> ResponseEntity.notFound().build());
  }

  @PostMapping("/transfers")
  public ResponseEntity<SbpTransferResponse> processSbpTransfer(
    @Valid @RequestBody SbpTransferRequest request
  ) {
    try {
      SbpTransferResponse response = sbpAdapterLogic.processTransfer(request);
      // Успех (даже если success=false из-за бизнес-правил) возвращаем 200 OK
      return ResponseEntity.ok(response);
    } catch (SbpBusinessException e) {
      // Ожидаемая бизнес-ошибка (банк недоступен, отказ по правилам) - 422
      SbpTransferResponse errorResponse = SbpTransferResponse.builder()
        .success(false)
        .errorMessage(e.getMessage())
        .build();
      return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(
        errorResponse
      );
    } catch (SbpTechnicalException e) {
      // Техническая ошибка SBP или адаптера - 500 или 503
      SbpTransferResponse errorResponse = SbpTransferResponse.builder()
        .success(false)
        .errorMessage(e.getMessage())
        .build();

      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
        errorResponse
      );
    }
  }
}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/SbpAdapterServiceApplication.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SbpAdapterServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(SbpAdapterServiceApplication.class, args);
	}

}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/service/SbpAdapterLogic.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.service;

import jakarta.annotation.PostConstruct;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import ru.sberbank.sbp.lab2.sbp_adapter_service.dto.BankInfo;
import ru.sberbank.sbp.lab2.sbp_adapter_service.dto.SbpTransferRequest;
import ru.sberbank.sbp.lab2.sbp_adapter_service.dto.SbpTransferResponse;
import ru.sberbank.sbp.lab2.sbp_adapter_service.exception.SbpBusinessException;
import ru.sberbank.sbp.lab2.sbp_adapter_service.exception.SbpTechnicalException;

@Service
@Slf4j
public class SbpAdapterLogic {

  private final Random random = ThreadLocalRandom.current();
  private final Map<String, BankInfo> bankRegistry = new ConcurrentHashMap<>();
  private final Map<String, List<String>> phoneToBankIds =
    new ConcurrentHashMap<>();

  private static final BigDecimal BUSINESS_ERROR_AMOUNT = new BigDecimal(
    "422.00"
  );
  private static final BigDecimal TECHNICAL_ERROR_AMOUNT = new BigDecimal(
    "500.00"
  );

  @PostConstruct
  void initializeMockData() {
    log.info("Initializing SBP Adapter Mock Data...");
    bankRegistry.put(
      "100000001",
      new BankInfo("100000001", "Alfa-Bank (Mock)", true)
    );
    bankRegistry.put(
      "100000002",
      new BankInfo("100000002", "SberBank (Mock)", true)
    );
    bankRegistry.put(
      "100000003",
      new BankInfo("100000003", "VTB (Mock)", true)
    );
    bankRegistry.put(
      "100000004",
      new BankInfo("100000004", "Tinkoff (Mock)", true)
    );
    bankRegistry.put(
      "100000009",
      new BankInfo("100000009", "Closed Bank (Mock)", false)
    );

    phoneToBankIds.put("9993334444", List.of("100000002", "100000001"));
    phoneToBankIds.put("9995556666", List.of("100000004"));
    phoneToBankIds.put("9997778888", List.of("100000003", "100000009"));
    phoneToBankIds.put("9990000009", List.of("100000009"));

    log.info(
      "Mock Data Initialized. Banks: {}, Phones: {}",
      bankRegistry.size(),
      phoneToBankIds.size()
    );
  }

  public Optional<BankInfo> findBank(String phoneNumber) {
    log.debug("SBP Adapter: Request to find bank for {}", phoneNumber);
    simulateNetworkDelay(50, 200);

    if (phoneNumber == null || !phoneNumber.matches("\\d{10}")) {
      log.warn("SBP Adapter: Invalid phone format {}", phoneNumber);
      return Optional.empty();
    }

    List<String> bankIdList = phoneToBankIds.get(phoneNumber);
    if (bankIdList == null || bankIdList.isEmpty()) {
      log.warn(
        "SBP Adapter: Phone number {} not associated with any bank",
        phoneNumber
      );
      return Optional.empty();
    }

    log.debug(
      "SBP Adapter: Found associated bank IDs for {}: {}",
      phoneNumber,
      bankIdList
    );

    for (String bankId : bankIdList) {
      BankInfo bankInfo = bankRegistry.get(bankId);
      if (bankInfo == null) {
        log.error(
          "SBP Adapter: Inconsistency - phone {} linked to non-existent bankId {}",
          phoneNumber,
          bankId
        );
        continue;
      }
      if (bankInfo.isSupportsSbp()) {
        log.info(
          "SBP Adapter: Found suitable SBP-enabled bank {} ({}) for {}",
          bankInfo.getBankName(),
          bankInfo.getBankId(),
          phoneNumber
        );
        return Optional.of(bankInfo);
      } else {
        log.debug(
          "SBP Adapter: Bank {} for phone {} does not support SBP, checking next...",
          bankInfo.getBankName(),
          phoneNumber
        );
      }
    }

    log.warn(
      "SBP Adapter: No SBP-enabled bank found for phone {}",
      phoneNumber
    );
    return Optional.empty();
  }

  public SbpTransferResponse processTransfer(SbpTransferRequest request)
    throws SbpBusinessException, SbpTechnicalException {
    log.debug(
      "SBP Adapter: Request to process transfer {}",
      request.getCorrelationId()
    );
    simulateNetworkDelay(150, 600);

    String sbpTxId =
      "SBP_TX_" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();

    if (BUSINESS_ERROR_AMOUNT.compareTo(request.getAmount()) == 0) {
      String error = "Forced Business Error (e.g., Limit Exceeded)";
      log.warn(
        "SBP Adapter: Transfer {} processing declined (forced by amount). Reason: {}",
        request.getCorrelationId(),
        error
      );
      throw new SbpBusinessException(error);
    }

    if (TECHNICAL_ERROR_AMOUNT.compareTo(request.getAmount()) == 0) {
      String error = "Forced Technical Error (e.g., SBP Unavailable)";
      log.error(
        "SBP Adapter: Transfer {} processing failed (forced by amount). Error: {}",
        request.getCorrelationId(),
        error
      );
      throw new SbpTechnicalException(error);
    }

    int scenario = random.nextInt(100);

    if (scenario < 90) {
      log.info(
        "SBP Adapter: Transfer {} processed successfully. SBP Tx ID: {}",
        request.getCorrelationId(),
        sbpTxId
      );
      return SbpTransferResponse.builder()
        .success(true)
        .sbpTransactionId(sbpTxId)
        .build();
    } else if (scenario < 95) {
      String error =
        "Recipient bank unavailable (Random Error B" +
        (100 + random.nextInt(99)) +
        ")";

      log.error(
        "SBP Adapter: Transfer {} processing failed. Error: {}",
        request.getCorrelationId(),
        error
      );
      throw new SbpBusinessException(error);
    } else {
      String error =
        "SBP technical error (Random Code S" + (500 + random.nextInt(99)) + ")";

      log.error(
        "SBP Adapter: Transfer {} processing failed. Error: {}",
        request.getCorrelationId(),
        error
      );
      throw new SbpTechnicalException(error);
    }
  }

  private void simulateNetworkDelay(long minMillis, long maxMillis) {
    try {
      long delay = minMillis + random.nextLong(maxMillis - minMillis + 1);
      Thread.sleep(delay);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      log.warn("SBP Adapter: Network delay simulation interrupted");
    }
  }
}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/exception/SbpTechnicalException.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.exception;

public class SbpTechnicalException extends RuntimeException {

  public SbpTechnicalException(String message) {
    super(message);
  }

  public SbpTechnicalException(String message, Throwable cause) {
    super(message, cause);
  }
}

**====================================**
path: sbp-adapter-service/src/main/java/ru/sberbank/sbp/lab2/sbp_adapter_service/exception/SbpBusinessException.java
contents:
package ru.sberbank.sbp.lab2.sbp_adapter_service.exception;

public class SbpBusinessException extends Exception {

  public SbpBusinessException(String message) {
    super(message);
  }
}

**====================================**
path: test.sh
contents:
#!/bin/bash

# set -x

echo "======================================"
echo " SBP Lab 2 - Полный тестовый скрипт  "
echo "======================================"
echo "Временная метка: $(date)"
echo "======================================"


# --- Конфигурация ---
BASE_URL="http://localhost:8080" # URL transfer-service
# SBP_ADAPTER_URL="http://localhost:8083" # URL sbp-adapter-service (не используется напрямую скриптом)
# NOTIFICATION_URL="http://localhost:8084" # URL notification-service (не используется напрямую скриптом)
# ACCOUNT_URL="http://localhost:8081" # URL account-service (не используется напрямую скриптом)

# --- Отправитель ---
SENDER_PHONE="9991112222"

# --- Получатели (На основе мок-данных SbpAdapterLogic) ---
# Получатель 1: Есть Сбер (Работает) и Альфа (Работает) - Целимся в Сбер
RECIPIENT_PHONE_SBER="9993334444"
RECIPIENT_BANK_ID_SBER="100000002" # SberBank (Mock)

# Получатель 2: Есть Тинькофф (Работает)
RECIPIENT_PHONE_TINKOFF="9995556666"
RECIPIENT_BANK_ID_TINKOFF="100000004" # Tinkoff (Mock)

# Получатель 3: Есть ВТБ (Работает) и Закрытый Банк (Не работает) - Целимся в ВТБ
RECIPIENT_PHONE_VTB="9997778888"
RECIPIENT_BANK_ID_VTB="100000003" # VTB (Mock)

# Получатель 4: Есть ТОЛЬКО Закрытый Банк (Не работает)
RECIPIENT_PHONE_CLOSED="9990000009"
RECIPIENT_BANK_ID_CLOSED="100000009" # Закрытый Банк (Mock) - Не поддерживает СБП


# --- Учетные данные ---
USER_CREDS="user:userpass"
ADMIN_CREDS="admin:adminpass"
INVALID_CREDS="user:wrongpassword"

# --- Суммы ---
SUCCESS_AMOUNT="100.50"
BUSINESS_ERROR_AMOUNT="422.00" # Для имитации SbpBusinessException
TECHNICAL_ERROR_AMOUNT="500.00" # Для имитации SbpTechnicalException
INVALID_CODE_AMOUNT="111.00" # Для тестов с неверным кодом
SMALL_AMOUNT="50.25"         # Другая небольшая сумма для разнообразия
LIMIT_TEST_AMOUNT_1="140000.00" # Для теста превышения лимита (часть 1)
LIMIT_TEST_AMOUNT_2="15000.00"  # Для теста превышения лимита (часть 2)


# --- Прочие настройки ---
MAX_CONFIRMATION_ATTEMPTS=3

# --- Функции ---
check_jq() {
  if ! command -v jq &> /dev/null; then
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
    echo "!! Ошибка: команда 'jq' не найдена.                       !!" >&2
    echo "!! Пожалуйста, установите jq.                             !!" >&2
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
    exit 1
  fi
  echo "[Инфо] jq найден."
}

get_confirmation_code_via_api() {
  local transfer_id=$1
  local code=""
  local local_rc=0 # Локальный код возврата

  echo "[Инфо] Попытка получить код подтверждения для $transfer_id через API (админ)..." >&2
  local output_file
  output_file=$(mktemp)
  local http_status
  http_status=$(curl -X GET "$BASE_URL/api/transfers/$transfer_id" \
           -u "$ADMIN_CREDS" \
           -H "X-Phone-Number: $SENDER_PHONE" \
           --connect-timeout 5 --max-time 10 \
           --silent --show-error --include --output "$output_file" --write-out "%{http_code}")

   local body
   body=$(awk 'BEGIN{found=0} /^(\r)?$/{found=1; next} found{print}' "$output_file")

  echo "[Отладка] Тело ответа Get Status для $transfer_id: $body" >&2

  if [ "$http_status" -eq 200 ]; then
      code=$(echo "$body" | jq -r '.confirmationCode // empty')
      if [ -z "$code" ] || [ "$code" == "null" ]; then
          echo -e "\033[0;31mОшибка: Не удалось извлечь confirmationCode из ответа API для $transfer_id! Тело: $body\033[0m" >&2
          local_rc=1
      else
          echo "[Инфо] Код подтверждения успешно извлечен: $code" >&2
          code=$(echo "$code" | tr -d '\r') # Убираем возможные символы возврата каретки
          echo "$code" # Выводим очищенный код
      fi
  else
      echo -e "\033[0;31mОшибка: Не удалось получить статус перевода для $transfer_id (Статус: $http_status). Невозможно получить код подтверждения.\033[0m" >&2
      echo "------- RAW GET STATUS OUTPUT (Admin) -------" >&2
      cat "$output_file" >&2
      echo "------------------------------------------" >&2
      local_rc=1
  fi
  rm "$output_file" &> /dev/null
  return $local_rc
}

print_result() {
    local test_name=$1
    local http_status=$2
    local expected_status=$3
    local response_body=$4
    local result_status=1 # Предполагаем FAIL

    http_status_cleaned=$(echo "$http_status" | tr -cd '0-9')

    echo -n "$test_name - Ожидаемый: $expected_status, Получен: $http_status_cleaned -> "
    if [[ "$http_status_cleaned" == "$expected_status" ]]; then
        echo -e "\033[0;32mPASS\033[0m"
        result_status=0 # PASS
    else
        echo -e "\033[0;31mFAIL\033[0m"
        result_status=1 # FAIL
    fi

    # Всегда выводим тело ответа, если оно не пустое
    if [ ! -z "$response_body" ]; then
      local body_to_print="$response_body"
      body_to_print=$(echo "$body_to_print" | tr -d '\n\r')
      echo "       Тело ответа: $body_to_print"
    fi

    sleep 0.2
    return $result_status
}

# --- Функция для запуска полного цикла перевода ---
# $1: run_index (Индекс запуска)
# $2: recipient_phone (Телефон получателя)
# $3: recipient_bank_id (ID банка получателя)
# $4: amount (Сумма)
# $5: confirmation_code_mode (Режим кода: CORRECT, INVALID, INVALID_MAX)
# $6: expected_confirm_http_status (Ожидаемый HTTP статус подтверждения)
# $7: expected_final_transfer_status (Ожидаемый финальный статус перевода)
# $8: test_prefix (Префикс теста)
run_transfer_flow() {
    local run_index=$1
    local recipient_phone=$2
    local recipient_bank_id=$3
    local amount=$4
    local confirmation_code_mode=$5
    local expected_confirm_http_status=$6
    local expected_final_transfer_status=$7
    local test_prefix=$8

    echo ""
    echo "--- ЗАПУСК ЦИКЛА ${test_prefix} ($run_index) Получатель: $recipient_phone, Банк: $recipient_bank_id, Сумма: $amount ---"
    local TRANSFER_ID=""
    local ACTUAL_CONFIRMATION_CODE=""
    local CODE_TO_SEND=""
    local RUN_FAILED=0

    # 1. Инициация перевода (USER)
    echo "[Тест ${test_prefix}-Init.$run_index] Инициация перевода (Пользователь)"
    INITIATE_OUTPUT_FILE=$(mktemp)
    INITIATE_STATUS=$(curl -X POST "$BASE_URL/api/transfers" \
         -u "$USER_CREDS" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" \
         -d '{"recipientPhoneNumber": "'$recipient_phone'","amount": '$amount',"bankId": "'$recipient_bank_id'"}' \
         --connect-timeout 5 --max-time 15 \
         --silent --show-error -o "$INITIATE_OUTPUT_FILE" --write-out "%{http_code}")
    INITIATE_BODY=$(cat "$INITIATE_OUTPUT_FILE"); rm "$INITIATE_OUTPUT_FILE" &> /dev/null
    if ! print_result "[Тест ${test_prefix}-Init.$run_index]" "$INITIATE_STATUS" 201 "$INITIATE_BODY"; then RUN_FAILED=1; fi

    if [ "$RUN_FAILED" -eq 0 ]; then
        TRANSFER_ID=$(echo "$INITIATE_BODY" | jq -r '.transferId // empty')
        if [ -z "$TRANSFER_ID" ] || [ "$TRANSFER_ID" == "null" ]; then echo -e "\033[0;31mОшибка: Не удалось извлечь transferId!\033[0m"; RUN_FAILED=1; else echo "       Получен Transfer ID: $TRANSFER_ID"; fi
    else echo -e "\033[0;31mОшибка: Инициация перевода не удалась.\033[0m"; fi

    # 2. Получение статуса (USER) - Проверка безопасности
    if [ "$RUN_FAILED" -eq 0 ]; then
        echo "[Тест ${test_prefix}-GetStatusUser.$run_index] Получение статуса $TRANSFER_ID (Пользователь)"
        STATUS_4=$(curl -X GET "$BASE_URL/api/transfers/$TRANSFER_ID" -u "$USER_CREDS" -H "X-Phone-Number: $SENDER_PHONE" --connect-timeout 5 --max-time 10 --silent --output /dev/null --write-out "%{http_code}")
        if ! print_result "[Тест ${test_prefix}-GetStatusUser.$run_index]" "$STATUS_4" 403; then RUN_FAILED=1; fi
    fi

    # 3. Получение кода (ADMIN)
    if [ "$RUN_FAILED" -eq 0 ]; then
        echo "[Тест ${test_prefix}-GetCode.$run_index] Получение статуса $TRANSFER_ID (Админ) для извлечения кода"
        ACTUAL_CONFIRMATION_CODE=$(get_confirmation_code_via_api "$TRANSFER_ID")
        GET_CODE_RC=$?
        if [ $GET_CODE_RC -ne 0 ] || [ -z "$ACTUAL_CONFIRMATION_CODE" ]; then
           echo -e "\033[0;31mОшибка: Не удалось получить код подтверждения! Пропуск теста подтверждения.\033[0m"
           RUN_FAILED=1
        else
           echo "       Реальный код подтверждения: [$ACTUAL_CONFIRMATION_CODE]"
           if [[ "$confirmation_code_mode" == "CORRECT" ]]; then CODE_TO_SEND="$ACTUAL_CONFIRMATION_CODE";
           elif [[ "$confirmation_code_mode" == "INVALID" || "$confirmation_code_mode" == "INVALID_MAX" ]]; then CODE_TO_SEND="000000"; if [[ "$CODE_TO_SEND" == "$ACTUAL_CONFIRMATION_CODE" ]]; then CODE_TO_SEND="111111"; fi
           else echo -e "\033[0;31mОшибка: Неизвестный режим '$confirmation_code_mode'!\033[0m"; RUN_FAILED=1; CODE_TO_SEND=""; fi
           if [[ "$RUN_FAILED" -eq 0 ]]; then echo "       Код для отправки в тесте: [$CODE_TO_SEND]"; fi
        fi
    fi

    # 4. Подтверждение (USER)
    if [ "$RUN_FAILED" -eq 0 ] && [ ! -z "$CODE_TO_SEND" ] ; then
        if [[ "$confirmation_code_mode" == "INVALID_MAX" ]]; then
            echo "[Тест ${test_prefix}-Confirm.$run_index] Подтверждение перевода $TRANSFER_ID (Пользователь) - Отправка НЕВЕРНОГО кода $MAX_CONFIRMATION_ATTEMPTS раз"
            local attempt confirm_output_file_inv json_data_inv confirm_status_inv confirm_body_inv expected_status_inv expected_message actual_message
            for attempt in $(seq 1 $MAX_CONFIRMATION_ATTEMPTS); do
                 confirm_output_file_inv=$(mktemp)
                 json_data_inv="{\"confirmationCode\": \"$CODE_TO_SEND\"}"
                 echo "       Отладка: Неверная попытка $attempt/$MAX_CONFIRMATION_ATTEMPTS JSON: ->$json_data_inv<-" >&2
                 confirm_status_inv=$(curl -X POST "$BASE_URL/api/transfers/$TRANSFER_ID/confirm" -u "$USER_CREDS" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" -d "$json_data_inv" --connect-timeout 5 --max-time 15 --silent --show-error -o "$confirm_output_file_inv" --write-out "%{http_code}")
                 confirm_body_inv=$(cat "$confirm_output_file_inv"); rm "$confirm_output_file_inv" &> /dev/null
                 expected_status_inv=200
                 if ! print_result "[Тест ${test_prefix}-Confirm-Attempt$attempt.$run_index]" "$confirm_status_inv" "$expected_status_inv" "$confirm_body_inv"; then RUN_FAILED=1; break; fi
                 if [[ $attempt -lt $MAX_CONFIRMATION_ATTEMPTS ]]; then expected_message="Invalid confirmation code. Attempts left: $(($MAX_CONFIRMATION_ATTEMPTS - attempt))"; else expected_message="Invalid confirmation code. Max attempts exceeded."; fi
                 actual_message=$(echo "$confirm_body_inv" | jq -r '.message // ""')
                 echo -n "       Проверка сообщения ответа: Ожидается '$expected_message', Получено '$actual_message' -> "
                 if [[ "$actual_message" == "$expected_message" ]]; then echo -e "\033[0;32mPASS\033[0m"; else echo -e "\033[0;31mFAIL\033[0m"; RUN_FAILED=1; break; fi
                 sleep 1
            done
            expected_confirm_http_status=200 # Общий ожидаемый статус для шага (последний запрос)
        else
            echo "[Тест ${test_prefix}-Confirm.$run_index] Подтверждение перевода $TRANSFER_ID (Пользователь)"
            CONFIRM_OUTPUT_FILE=$(mktemp)
            JSON_DATA="{\"confirmationCode\": \"$CODE_TO_SEND\"}"
            echo "       Отладка: JSON данные для запроса подтверждения: ->$JSON_DATA<-" >&2
            CONFIRM_STATUS=$(curl -X POST "$BASE_URL/api/transfers/$TRANSFER_ID/confirm" -u "$USER_CREDS" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" -d "$JSON_DATA" --connect-timeout 5 --max-time 15 --silent --show-error -o "$CONFIRM_OUTPUT_FILE" --write-out "%{http_code}")
            CONFIRM_BODY=$(cat "$CONFIRM_OUTPUT_FILE"); rm "$CONFIRM_OUTPUT_FILE" &> /dev/null
            if ! print_result "[Тест ${test_prefix}-Confirm.$run_index]" "$CONFIRM_STATUS" "$expected_confirm_http_status" "$CONFIRM_BODY"; then RUN_FAILED=1; fi
            if [[ "$CONFIRM_STATUS" =~ ^5[0-9]{2}$ ]] || [[ "$CONFIRM_STATUS" == "000" ]]; then echo "       Тело ошибки: $CONFIRM_BODY"; fi
        fi
    fi

    # 5. Финальная проверка статуса (ADMIN)
    if [ ! -z "$TRANSFER_ID" ]; then
        echo "[Тест ${test_prefix}-FinalStatus.$run_index] Получение финального статуса $TRANSFER_ID (Админ)"
        sleep 1 # Небольшая пауза перед проверкой финального статуса
        FINAL_OUTPUT_FILE=$(mktemp)
        FINAL_STATUS_CODE=$(curl -X GET "$BASE_URL/api/transfers/$TRANSFER_ID" \
             -u "$ADMIN_CREDS" -H "X-Phone-Number: $SENDER_PHONE" \
             --connect-timeout 5 --max-time 10 \
             --silent --show-error -o "$FINAL_OUTPUT_FILE" --write-out "%{http_code}")
        FINAL_BODY=$(cat "$FINAL_OUTPUT_FILE"); rm "$FINAL_OUTPUT_FILE" &> /dev/null
        print_result "[Тест ${test_prefix}-FinalStatus.$run_index]" "$FINAL_STATUS_CODE" 200 "$FINAL_BODY"

        if [ "$FINAL_STATUS_CODE" -eq 200 ]; then
            actual_final_status=$(echo "$FINAL_BODY" | jq -r '.status // "UNKNOWN"')
            echo -n "       Проверка финального статуса перевода: Ожидается '$expected_final_transfer_status', Получено '$actual_final_status' -> "
            if [ "$actual_final_status" == "$expected_final_transfer_status" ]; then echo -e "\033[0;32mPASS\033[0m"; else echo -e "\033[0;31mFAIL\033[0m"; RUN_FAILED=1; fi
        else
             RUN_FAILED=1
        fi
    else
        echo "Пропуск финальной проверки статуса, так как TRANSFER_ID отсутствует."
        RUN_FAILED=1
    fi


    if [ "$RUN_FAILED" -ne 0 ]; then
      FAILED_RUNS=$((FAILED_RUNS + 1))
      echo -e "\033[0;31m--- ЗАПУСК ЦИКЛА ${test_prefix} ($run_index) ЗАВЕРШИЛСЯ С ОШИБКОЙ ---\033[0m"
      return 1
    else
      echo -e "\033[0;32m--- ЗАПУСК ЦИКЛА ${test_prefix} ($run_index) ПРОШЕЛ УСПЕШНО ---\033[0m"
      return 0
    fi
}


# --- Основное выполнение скрипта ---
check_jq

# --- Начальные проверки безопасности ---
echo ""
echo "--- Запуск начальных проверок безопасности ---"
echo "[Тест Sec-1.0] Инициация перевода (Неавторизован)"
STATUS_1=$(curl -X POST "$BASE_URL/api/transfers" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" -d '{"recipientPhoneNumber": "'$RECIPIENT_PHONE_SBER'","amount": 1.00,"bankId": "sec-check-1"}' --connect-timeout 5 --max-time 10 --silent --output /dev/null --write-out "%{http_code}")
print_result "[Тест Sec-1.0]" "$STATUS_1" 401 ""
echo "[Тест Sec-2.0] Инициация перевода (Неверные учетные данные)"
STATUS_2=$(curl -X POST "$BASE_URL/api/transfers" -u "$INVALID_CREDS" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" -d '{"recipientPhoneNumber": "'$RECIPIENT_PHONE_SBER'","amount": 2.00,"bankId": "sec-check-2"}' --connect-timeout 5 --max-time 10 --silent --output /dev/null --write-out "%{http_code}")
print_result "[Тест Sec-2.0]" "$STATUS_2" 401 ""

# --- Запуск сценариев ---
echo ""
echo "--- Запуск основных сценариев ---"
FAILED_RUNS=0

# Сценарий 1: Успешный перевод (Получатель SBER)
run_transfer_flow 1 "$RECIPIENT_PHONE_SBER" "$RECIPIENT_BANK_ID_SBER" "$SUCCESS_AMOUNT" "CORRECT" 200 "SUCCESSFUL" "SuccessSber"
if [[ $? -ne 0 ]]; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi

# Сценарий 2: Ошибка бизнес-логики SBP (Получатель TINKOFF)
run_transfer_flow 2 "$RECIPIENT_PHONE_TINKOFF" "$RECIPIENT_BANK_ID_TINKOFF" "$BUSINESS_ERROR_AMOUNT" "CORRECT" 200 "FAILED" "BizErrTinkoff"
if [[ $? -ne 0 ]]; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi

# Сценарий 3: Техническая ошибка SBP (Получатель VTB)
run_transfer_flow 3 "$RECIPIENT_PHONE_VTB" "$RECIPIENT_BANK_ID_VTB" "$TECHNICAL_ERROR_AMOUNT" "CORRECT" 200 "FAILED" "TechErrVtb"
if [[ $? -ne 0 ]]; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi

# Сценарий 4: Неверный код подтверждения (1 раз) (Получатель SBER)
run_transfer_flow 4 "$RECIPIENT_PHONE_SBER" "$RECIPIENT_BANK_ID_SBER" "$INVALID_CODE_AMOUNT" "INVALID" 200 "AWAITING_CONFIRMATION" "InvCodeSber"
if [[ $? -ne 0 ]]; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi

# Сценарий 5: Неверный код подтверждения (максимум попыток) (Получатель TINKOFF)
run_transfer_flow 5 "$RECIPIENT_PHONE_TINKOFF" "$RECIPIENT_BANK_ID_TINKOFF" "$INVALID_CODE_AMOUNT" "INVALID_MAX" 200 "FAILED" "InvCodeMaxTinkoff"
if [[ $? -ne 0 ]]; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi

# Сценарий 6: Успешный перевод другому получателю (VTB)
run_transfer_flow 6 "$RECIPIENT_PHONE_VTB" "$RECIPIENT_BANK_ID_VTB" "$SMALL_AMOUNT" "CORRECT" 200 "SUCCESSFUL" "SuccessVtb"
if [[ $? -ne 0 ]]; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi


# --- Сценарий 7: Превышение дневного лимита ---
echo ""
echo "--- ЗАПУСК ЦИКЛА LimitExceed (7) ---"
# Используем получателя SBER для теста лимита
echo "[Тест LimitExceed-Setup.7] Выполнение первого крупного перевода (Получатель: $RECIPIENT_PHONE_SBER, Сумма: $LIMIT_TEST_AMOUNT_1)..."
run_transfer_flow 7 "$RECIPIENT_PHONE_SBER" "$RECIPIENT_BANK_ID_SBER" "$LIMIT_TEST_AMOUNT_1" "CORRECT" 200 "SUCCESSFUL" "LimitSetupSber"
SETUP_PASSED=$?
if [[ $SETUP_PASSED -ne 0 ]]; then
    echo -e "\033[0;31mОшибка: Перевод для настройки лимита не удался. Пропуск теста превышения лимита.\033[0m"
    FAILED_RUNS=$((FAILED_RUNS + 1))
else
    echo "[Тест LimitExceed-Check.7] Попытка перевода, превышающего лимит (Получатель: $RECIPIENT_PHONE_SBER, Сумма: $LIMIT_TEST_AMOUNT_2)"
    LIMIT_OUTPUT_FILE=$(mktemp)
    LIMIT_STATUS=$(curl -X POST "$BASE_URL/api/transfers" \
         -u "$USER_CREDS" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" \
         -d '{"recipientPhoneNumber": "'$RECIPIENT_PHONE_SBER'","amount": '$LIMIT_TEST_AMOUNT_2',"bankId": "'$RECIPIENT_BANK_ID_SBER'"}' \
         --connect-timeout 5 --max-time 15 \
         --silent --show-error -o "$LIMIT_OUTPUT_FILE" --write-out "%{http_code}")
    LIMIT_BODY=$(cat "$LIMIT_OUTPUT_FILE"); rm "$LIMIT_OUTPUT_FILE" &> /dev/null
    # Ожидаем 400 Bad Request, так как TransferLimitExceededException должен обрабатываться GlobalExceptionHandler
    if ! print_result "[Тест LimitExceed-Check.7]" "$LIMIT_STATUS" 400 "$LIMIT_BODY"; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi
    if [[ "$LIMIT_STATUS" -eq 400 ]]; then
        if echo "$LIMIT_BODY" | jq -e '.message | test("Daily transfer limit exceeded")' > /dev/null; then
            echo "       Проверка сообщения об ошибке: Найдено 'Daily transfer limit exceeded' -> PASS"
        else
            echo "       Проверка сообщения об ошибке: Ожидаемое сообщение не найдено -> FAIL"
            # FAILED_RUNS=$((FAILED_RUNS + 1)) # Можно раскомментировать, если считаем это провалом
        fi
    fi
fi


# --- Сценарий 8: Попытка перевода получателю с банком, не поддерживающим СБП ---
echo ""
echo "--- ЗАПУСК ЦИКЛА NonSbpBank (8) ---"
echo "[Тест NonSbpBank-Init.8] Инициация перевода получателю с банком без поддержки СБП (Телефон: $RECIPIENT_PHONE_CLOSED, Банк: $RECIPIENT_BANK_ID_CLOSED)"
NON_SBP_OUTPUT_FILE=$(mktemp)
NON_SBP_STATUS=$(curl -X POST "$BASE_URL/api/transfers" \
     -u "$USER_CREDS" -H "Content-Type: application/json" -H "X-Phone-Number: $SENDER_PHONE" \
     -d '{"recipientPhoneNumber": "'$RECIPIENT_PHONE_CLOSED'","amount": '$SMALL_AMOUNT',"bankId": "'$RECIPIENT_BANK_ID_CLOSED'"}' \
     --connect-timeout 5 --max-time 15 \
     --silent --show-error -o "$NON_SBP_OUTPUT_FILE" --write-out "%{http_code}")
NON_SBP_BODY=$(cat "$NON_SBP_OUTPUT_FILE"); rm "$NON_SBP_OUTPUT_FILE" &> /dev/null
# Ожидаем ошибку 400 или 422, так как SbpAdapter вернет Optional.empty() и TransferService должен выдать исключение (например, BankNotFoundException или RecipientBankNotAvailableException)
# Точный код зависит от реализации обработчика исключений. Предположим 400.
if ! print_result "[Тест NonSbpBank-Init.8]" "$NON_SBP_STATUS" 400 "$NON_SBP_BODY"; then FAILED_RUNS=$((FAILED_RUNS + 1)); fi
# Дополнительная проверка сообщения (опционально)
if [[ "$NON_SBP_STATUS" -eq 400 ]]; then
    if echo "$NON_SBP_BODY" | jq -e '.message | test("Recipient bank .* does not support SBP")' > /dev/null || \
       echo "$NON_SBP_BODY" | jq -e '.message | test("Bank with ID .* not found or does not support SBP")' > /dev/null || \
       echo "$NON_SBP_BODY" | jq -e '.message | test("Recipient bank not available")' > /dev/null ; then # Проверяем разные возможные сообщения
        echo "       Проверка сообщения об ошибке: Найдено ожидаемое сообщение об ошибке банка -> PASS"
    else
        echo "       Проверка сообщения об ошибке: Ожидаемое сообщение не найдено -> FAIL"
    fi
fi


# --- Итоговый результат ---
echo ""
echo "======================================"
echo " Тестовый скрипт завершен           "
echo "======================================"
if [ $FAILED_RUNS -gt 0 ]; then
  echo -e "\033[0;31m $FAILED_RUNS сценарий(ев) завершились с ошибкой.\033[0m"
  exit 1 # Завершаем скрипт с кодом ошибки
else
  echo -e "\033[0;32m Все сценарии прошли успешно.\033[0m"
  exit 0 # Завершаем скрипт успешно
fi

# set +x
**====================================**
path: transfer-service/target/classes/application.properties
contents:
# Server Configuration
server.port=8080
spring.application.name=transfer-service

# === Atomikos JTA Configuration ===
spring.jta.enabled=true

# --- Atomikos Core Settings ---
spring.jta.atomikos.properties.service=com.atomikos.icatch.standalone.UserTransactionServiceFactory
spring.jta.atomikos.properties.max-timeout=300000
spring.jta.atomikos.properties.enable-logging=true
# logging.level.com.atomikos=TRACE

# --- Atomikos XA DataSource Configuration ---
spring.jta.atomikos.datasource.unique-resource-name=transferPostgresXA
spring.jta.atomikos.datasource.xa-data-source-class-name=org.postgresql.xa.PGXADataSource
spring.jta.atomikos.datasource.xa-properties.user=${POSTGRES_TRANSFER_USER:transfer_user}
spring.jta.atomikos.datasource.xa-properties.password=${POSTGRES_TRANSFER_PASSWORD:your_transfer_password}
spring.jta.atomikos.datasource.xa-properties.url=${POSTGRES_TRANSFER_URL:jdbc:postgresql://localhost:5432/transfer_db}
spring.jta.atomikos.datasource.max-pool-size=10
spring.jta.atomikos.datasource.min-pool-size=2
spring.jta.atomikos.datasource.test-query=SELECT 1

# --- Atomikos XA JMS ConnectionFactory Configuration ---
# Можно использовать то же имя, если это тот же брокер, или другое, если брокеры разные
spring.jta.atomikos.connectionfactory.unique-resource-name=activemqXA
spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name=org.apache.activemq.ActiveMQXAConnectionFactory
spring.jta.atomikos.connectionfactory.xa-properties.broker-url=${ACTIVEMQ_BROKER_URL:tcp://localhost:61616}
spring.jta.atomikos.connectionfactory.xa-properties.user=${ACTIVEMQ_USER:}
spring.jta.atomikos.connectionfactory.xa-properties.password=${ACTIVEMQ_PASSWORD:}
spring.jta.atomikos.connectionfactory.max-pool-size=10

# === JPA/Hibernate Configuration ===
spring.jpa.properties.hibernate.transaction.jta.platform=org.hibernate.engine.transaction.jta.platform.internal.AtomikosJtaPlatform
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# === JMS Template Configuration ===
# Убедимся, что JmsTemplate участвует в транзакции
# spring.jms.template.session-transacted=true
# spring.jms.template.delivery-mode=persistent
spring.activemq.packages.trust-all=true

# Logging
logging.level.root=INFO
logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF
logging.level.org.springframework.transaction.jta=TRACE
logging.level.org.springframework.jms=DEBUG
# Логи Spring Security
logging.level.org.springframework.security=TRACE
# Логи LoginModule
logging.level.ru.sberbank.sbp.lab2.transfer_service.security.jaas=TRACE

# Integration Settings
integration.sbp-adapter.base-url=http://localhost:8083
**====================================**
path: transfer-service/HELP.md
contents:
# Read Me First
The following was discovered as part of building this project:

* The original package name 'ru.sberbank.sbp.lab2.transfer-service' is invalid and this project uses 'ru.sberbank.sbp.lab2.transfer_service' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.4.4/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.4.4/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.4.4/reference/web/servlet.html)
* [Spring Data JPA](https://docs.spring.io/spring-boot/3.4.4/reference/data/sql.html#data.sql.jpa-and-spring-data)
* [Spring for Apache ActiveMQ 5](https://docs.spring.io/spring-boot/3.4.4/reference/messaging/jms.html#messaging.jms.activemq)
* [Spring Security](https://docs.spring.io/spring-boot/3.4.4/reference/web/spring-security.html)
* [Spring Web Services](https://docs.spring.io/spring-boot/3.4.4/reference/io/webservices.html)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)
* [Java Message Service API via Apache ActiveMQ Classic.](https://spring.io/guides/gs/messaging-jms/)
* [Securing a Web Application](https://spring.io/guides/gs/securing-web/)
* [Spring Boot and OAuth2](https://spring.io/guides/tutorials/spring-boot-oauth2/)
* [Authenticating a User with LDAP](https://spring.io/guides/gs/authenticating-ldap/)
* [Producing a SOAP web service](https://spring.io/guides/gs/producing-web-service/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


**====================================**
path: transfer-service/.gitignore
contents:
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

**====================================**
path: transfer-service/.mvn/wrapper/maven-wrapper.properties
contents:
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip

**====================================**
path: transfer-service/.gitattributes
contents:
/mvnw text eol=lf
*.cmd text eol=crlf

**====================================**
path: transfer-service/mvnw
contents:
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

**====================================**
path: transfer-service/src/test/test2.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="true" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: transfer-service/src/test/java/ru/sberbank/sbp/lab2/transfer_service/TransferServiceApplicationTests.java
contents:
package ru.sberbank.sbp.lab2.transfer_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TransferServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

**====================================**
path: transfer-service/src/main/main2.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/java" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
**====================================**
path: transfer-service/src/main/resources/application.properties
contents:
# Server Configuration
server.port=8080
spring.application.name=transfer-service

# === Atomikos JTA Configuration ===
spring.jta.enabled=true

# --- Atomikos Core Settings ---
spring.jta.atomikos.properties.service=com.atomikos.icatch.standalone.UserTransactionServiceFactory
spring.jta.atomikos.properties.max-timeout=300000
spring.jta.atomikos.properties.enable-logging=true
# logging.level.com.atomikos=TRACE

# --- Atomikos XA DataSource Configuration ---
spring.jta.atomikos.datasource.unique-resource-name=transferPostgresXA
spring.jta.atomikos.datasource.xa-data-source-class-name=org.postgresql.xa.PGXADataSource
spring.jta.atomikos.datasource.xa-properties.user=${POSTGRES_TRANSFER_USER:transfer_user}
spring.jta.atomikos.datasource.xa-properties.password=${POSTGRES_TRANSFER_PASSWORD:your_transfer_password}
spring.jta.atomikos.datasource.xa-properties.url=${POSTGRES_TRANSFER_URL:jdbc:postgresql://localhost:5432/transfer_db}
spring.jta.atomikos.datasource.max-pool-size=10
spring.jta.atomikos.datasource.min-pool-size=2
spring.jta.atomikos.datasource.test-query=SELECT 1

# --- Atomikos XA JMS ConnectionFactory Configuration ---
# Можно использовать то же имя, если это тот же брокер, или другое, если брокеры разные
spring.jta.atomikos.connectionfactory.unique-resource-name=activemqXA
spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name=org.apache.activemq.ActiveMQXAConnectionFactory
spring.jta.atomikos.connectionfactory.xa-properties.broker-url=${ACTIVEMQ_BROKER_URL:tcp://localhost:61616}
spring.jta.atomikos.connectionfactory.xa-properties.user=${ACTIVEMQ_USER:}
spring.jta.atomikos.connectionfactory.xa-properties.password=${ACTIVEMQ_PASSWORD:}
spring.jta.atomikos.connectionfactory.max-pool-size=10

# === JPA/Hibernate Configuration ===
spring.jpa.properties.hibernate.transaction.jta.platform=org.hibernate.engine.transaction.jta.platform.internal.AtomikosJtaPlatform
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# === JMS Template Configuration ===
# Убедимся, что JmsTemplate участвует в транзакции
# spring.jms.template.session-transacted=true
# spring.jms.template.delivery-mode=persistent
spring.activemq.packages.trust-all=true

# Logging
logging.level.root=INFO
logging.level.org.hibernate.SQL=OFF
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=OFF
logging.level.org.springframework.transaction.jta=TRACE
logging.level.org.springframework.jms=DEBUG
# Логи Spring Security
logging.level.org.springframework.security=TRACE
# Логи LoginModule
logging.level.ru.sberbank.sbp.lab2.transfer_service.security.jaas=TRACE

# Integration Settings
integration.sbp-adapter.base-url=http://localhost:8083
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/ConfirmTransferRequest.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class ConfirmTransferRequest {

  @NotBlank(message = "Код подтверждения обязателен")
  @Size(
    min = 6,
    max = 6,
    message = "Код подтверждения должен состоять из 6 цифр"
  ) // Пример валидации длины
  private String confirmationCode;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/TransferConfirmationResponse.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto;

import java.util.UUID;
import lombok.Value;
import ru.sberbank.sbp.lab2.transfer_service.entity.enums.TransferStatus; // Импорт статуса

@Value
public class TransferConfirmationResponse {

  UUID transferId;
  TransferStatus status; // Финальный статус (SUCCESSFUL, FAILED, ...)
  String message; // Сообщение об ошибке или успехе
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/InitiateTransferRequest.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import java.math.BigDecimal;
import lombok.Data;

@Data // Геттеры, сеттеры, equals, hashCode, toString
public class InitiateTransferRequest {

  @NotBlank(message = "Номер телефона получателя обязателен")
  @Pattern(
    regexp = "\\d{10}",
    message = "Номер телефона получателя должен состоять из 10 цифр"
  )
  private String recipientPhoneNumber;

  @NotBlank(message = "Идентификатор банка получателя обязателен")
  private String bankId; // BIC или другой идентификатор банка получателя

  @NotNull(message = "Сумма перевода обязательна")
  @DecimalMin(value = "0.01", message = "Сумма перевода должна быть больше 0")
  private BigDecimal amount;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/ErrorResponse.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto;

import lombok.Value;

@Value
public class ErrorResponse {

  String timestamp;
  int status;
  String error;
  String message;
  String path;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/SendSuccessNotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SendSuccessNotificationCommand implements NotificationCommand {

  private static final long serialVersionUID = 1L;
  private String senderPhoneNumber; // кому отправлять
  private BigDecimal amount;
  private String recipientInfo; // Инфо о получателе (номер/банк)
  private UUID correlationId;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/SendFailureNotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SendFailureNotificationCommand implements NotificationCommand {

  private static final long serialVersionUID = 1L;
  private String senderPhoneNumber; // кому отправлять
  private BigDecimal amount;
  private String reason; // причина неудачи
  private UUID correlationId;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/NotificationCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.io.Serializable;
import java.util.UUID;

// Опциональный общий интерфейс для команд уведомлений
public interface NotificationCommand extends Serializable {
  UUID getCorrelationId(); // ID исходного перевода
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/SendConfirmationCodeCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SendConfirmationCodeCommand implements NotificationCommand {

  private static final long serialVersionUID = 1L;
  private String phoneNumber;
  private String code;
  private UUID correlationId;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/CompleteTransferCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CompleteTransferCommand implements AccountServiceCommand {

  private static final long serialVersionUID = 1L;

  private String senderPhoneNumber;
  private String recipientPhoneNumber;
  private BigDecimal amount;
  private UUID correlationId; // ID оригинального перевода (Transfer.id)
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/ReserveFundsCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReserveFundsCommand implements AccountServiceCommand {

  private static final long serialVersionUID = 1L;

  private String phoneNumber;
  private BigDecimal amount;
  private UUID correlationId; // ID перевода Transfer.id
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/AccountServiceCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.io.Serializable;
import java.util.UUID;

public interface AccountServiceCommand extends Serializable {
     UUID getCorrelationId();
}
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/jms/ReleaseFundsCommand.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto.jms;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReleaseFundsCommand implements AccountServiceCommand {

  private static final long serialVersionUID = 1L;
  private String phoneNumber;
  private BigDecimal amount; // Сумма, которую нужно освободить
  private UUID correlationId; // ID перевода
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/dto/TransferInitiationResponse.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.dto;

import java.util.UUID;
import lombok.Value;
import ru.sberbank.sbp.lab2.transfer_service.entity.enums.TransferStatus;

@Value // Неизменяемый DTO, только геттеры, equals, hashCode, toString, конструктор со всеми полями
public class TransferInitiationResponse {

  UUID transferId;
  TransferStatus status; // Статус после инициации (обычно AWAITING_CONFIRMATION)
  String recipientBankName; // Имя банка получателя (если известно)
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/repository/TransferRepository.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.repository;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import ru.sberbank.sbp.lab2.transfer_service.entity.Transfer;
import ru.sberbank.sbp.lab2.transfer_service.entity.enums.TransferStatus;

@Repository
public interface TransferRepository extends JpaRepository<Transfer, UUID> {
  List<Transfer> findBySenderPhoneNumberOrderByCreatedAtDesc(
    String phoneNumber,
    Pageable pageable
  );

  // Сумма успешных переводов пользователя за период (для лимитов)
  @Query(
    "SELECT COALESCE(SUM(t.amount), 0) FROM Transfer t WHERE t.senderPhoneNumber = :phoneNumber " +
    "AND t.createdAt >= :startDate AND t.status = 'SUCCESSFUL'"
  )
  BigDecimal sumSuccessfulTransferAmountsByPhoneNumberAndDate(
    @Param("phoneNumber") String phoneNumber,
    @Param("startDate") LocalDateTime startDate
  );

  // Поиск "зависших" переводов (для возможной фоновой обработки)
  @Query(
    "SELECT t FROM Transfer t WHERE t.status = 'PROCESSING' AND t.createdAt < :timeout"
  )
  List<Transfer> findStuckProcessingTransfers(
    @Param("timeout") LocalDateTime timeout
  );
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/config/SecurityConfig.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.config;

// Убран импорт javax.security.auth.login.Configuration
import java.io.IOException;
import java.security.Principal;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.jaas.AuthorityGranter;
import org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler;
import org.springframework.security.authentication.jaas.JaasAuthenticationProvider;
import org.springframework.security.authentication.jaas.JaasNameCallbackHandler;
import org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import ru.sberbank.sbp.lab2.transfer_service.security.jaas.RolePrincipal;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

  private static final org.slf4j.Logger log = LoggerFactory.getLogger(
    SecurityConfig.class
  );

  @Value("${java.security.auth.login.config:classpath:jaas.conf}")
  private Resource jaasConfigResource;

  private static final String JAAS_LOGIN_CONTEXT_NAME = "SbpLogin";

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public AuthorityGranter authorityGranter() {
    return (Principal principal) -> {
      Set<String> roles = null;
      if (principal instanceof RolePrincipal) {
        if (roles == null) {
          roles = new HashSet<>();
        }
        roles.add(principal.getName());
      }
      return roles;
    };
  }

  @Bean
  public JaasAuthenticationCallbackHandler jaasNameCallbackHandler() {
    return new JaasNameCallbackHandler();
  }

  @Bean
  public JaasAuthenticationCallbackHandler jaasPasswordCallbackHandler() {
    return new JaasPasswordCallbackHandler();
  }

  @Bean
  public JaasAuthenticationProvider jaasAuthenticationProvider(
    AuthorityGranter authorityGranter,
    JaasAuthenticationCallbackHandler jaasNameCallbackHandler,
    JaasAuthenticationCallbackHandler jaasPasswordCallbackHandler
  ) {
    JaasAuthenticationProvider provider = new JaasAuthenticationProvider();
    provider.setAuthorityGranters(new AuthorityGranter[] { authorityGranter });
    provider.setCallbackHandlers(
      new JaasAuthenticationCallbackHandler[] {
        jaasNameCallbackHandler,
        jaasPasswordCallbackHandler,
      }
    );
    provider.setLoginContextName(JAAS_LOGIN_CONTEXT_NAME);

    provider.setLoginConfig(jaasConfigResource);
    log.info(
      "Setting loginConfig for JaasAuthenticationProvider to: {}",
      jaasConfigResource
    ); // Добавим лог

    try {
      provider.afterPropertiesSet();
    } catch (Exception e) {
      throw new RuntimeException(
        "Failed to initialize JaasAuthenticationProvider",
        e
      );
    }

    return provider;
  }

  @Bean
  public AuthenticationManager authenticationManager(
    JaasAuthenticationProvider jaasAuthenticationProvider
  ) {
    return new ProviderManager(
      Collections.singletonList(jaasAuthenticationProvider)
    );
  }

  @Bean
  public SecurityFilterChain securityFilterChain(
    HttpSecurity http,
    AuthenticationManager authenticationManager
  ) throws Exception {
    http
      .csrf(AbstractHttpConfigurer::disable)
      .authenticationManager(authenticationManager)
      .httpBasic(Customizer.withDefaults())
      .sessionManagement(session ->
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      )
      .authorizeHttpRequests(auth ->
        auth
          // 2. Эндпоинт получения статуса (GET /api/transfers/{id}) - только ADMIN
          // Используем HttpMethod для конкретизации
          .requestMatchers(
            org.springframework.http.HttpMethod.GET,
            "/api/transfers/*"
          ) // Используем * как placeholder для ID
          .hasRole("ADMIN") // <-- Требуем роль ADMIN
          // 3. Эндпоинт инициации (POST /api/transfers) - только USER
          .requestMatchers(
            org.springframework.http.HttpMethod.POST,
            "/api/transfers"
          )
          .hasRole("USER") // <-- Требуем роль USER
          // 4. Эндпоинт подтверждения (POST /api/transfers/{id}/confirm) - только USER
          .requestMatchers(
            org.springframework.http.HttpMethod.POST,
            "/api/transfers/*/confirm"
          ) // Используем * для ID
          .hasRole("USER") // <-- Требуем роль USER
          .anyRequest()
          .authenticated()
      );

    return http.build();
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/config/properties/AtomikosDataSourceProperties.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.config.properties;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = "spring.jta.atomikos.datasource")
@Validated
public class AtomikosDataSourceProperties {

  @NotEmpty
  private String uniqueResourceName;

  @NotNull
  private XaProperties xaProperties = new XaProperties();

  private int maxPoolSize = 10;
  private int minPoolSize = 2;
  private String testQuery = "SELECT 1";

  // --- Геттеры и Сеттеры ---

  public String getUniqueResourceName() {
    return uniqueResourceName;
  }

  public void setUniqueResourceName(String uniqueResourceName) {
    this.uniqueResourceName = uniqueResourceName;
  }

  public XaProperties getXaProperties() {
    return xaProperties;
  }

  public void setXaProperties(XaProperties xaProperties) {
    this.xaProperties = xaProperties;
  }

  public int getMaxPoolSize() {
    return maxPoolSize;
  }

  public void setMaxPoolSize(int maxPoolSize) {
    this.maxPoolSize = maxPoolSize;
  }

  public int getMinPoolSize() {
    return minPoolSize;
  }

  public void setMinPoolSize(int minPoolSize) {
    this.minPoolSize = minPoolSize;
  }

  public String getTestQuery() {
    return testQuery;
  }

  public void setTestQuery(String testQuery) {
    this.testQuery = testQuery;
  }

  public static class XaProperties {

    @NotEmpty
    private String url;

    @NotEmpty
    private String user;

    private String password;

    public String getUrl() {
      return url;
    }

    public void setUrl(String url) {
      this.url = url;
    }

    public String getUser() {
      return user;
    }

    public void setUser(String user) {
      this.user = user;
    }

    public String getPassword() {
      return password;
    }

    public void setPassword(String password) {
      this.password = password;
    }
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/config/DataSourceConfig.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.config;

import com.atomikos.jdbc.AtomikosDataSourceBean;
import javax.sql.DataSource;
import org.postgresql.xa.PGXADataSource;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import ru.sberbank.sbp.lab2.transfer_service.config.properties.AtomikosDataSourceProperties;

@Configuration
@EnableConfigurationProperties(AtomikosDataSourceProperties.class)
public class DataSourceConfig {

  @Bean(name = "dataSource", initMethod = "init", destroyMethod = "close")
  public DataSource dataSource(AtomikosDataSourceProperties properties) {
    PGXADataSource pgXaDataSource = new PGXADataSource();

    pgXaDataSource.setUrl(properties.getXaProperties().getUrl());
    pgXaDataSource.setUser(properties.getXaProperties().getUser());
    pgXaDataSource.setPassword(properties.getXaProperties().getPassword());

    AtomikosDataSourceBean atomikosDataSourceBean =
      new AtomikosDataSourceBean();
    atomikosDataSourceBean.setXaDataSource(pgXaDataSource);
    atomikosDataSourceBean.setUniqueResourceName(
      properties.getUniqueResourceName()
    );
    atomikosDataSourceBean.setMaxPoolSize(properties.getMaxPoolSize());
    atomikosDataSourceBean.setMinPoolSize(properties.getMinPoolSize());
    atomikosDataSourceBean.setTestQuery(properties.getTestQuery());

    System.out.println(
      "Initializing AtomikosDataSourceBean for transfer-service with URL: " +
      properties.getXaProperties().getUrl()
    );

    return atomikosDataSourceBean;
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/security/XmlLoginModule.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.security.jaas;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.security.Principal;
import java.util.*;
import javax.security.auth.Subject;
import javax.security.auth.callback.*;
import javax.security.auth.login.LoginException;
import javax.security.auth.spi.LoginModule;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

public class XmlLoginModule implements LoginModule {

  private static final Logger log = LoggerFactory.getLogger(
    XmlLoginModule.class
  );

  // Состояние модуля
  private Subject subject;
  private CallbackHandler callbackHandler;
  private Map<String, ?> options;

  // Данные пользователя после успешной аутентификации
  private String authenticatedUsername;
  private final List<Principal> principalsToAdd = new ArrayList<>(); // Сохраняем здесь до commit
  private boolean succeeded = false;

  // Используем BCrypt для проверки паролей
  private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

  @Override
  public void initialize(
    Subject subject,
    CallbackHandler callbackHandler,
    Map<String, ?> sharedState,
    Map<String, ?> options
  ) {
    this.subject = subject;
    this.callbackHandler = callbackHandler;
    this.options = options;
    log.trace("XmlLoginModule initialized."); // Используем TRACE для детальных логов
  }

  @Override
  public boolean login() throws LoginException {
    log.trace("XmlLoginModule login starting...");
    succeeded = false; // Сбрасываем флаг при каждой попытке входа
    principalsToAdd.clear(); // Очищаем временные principals

    if (callbackHandler == null) {
      throw new LoginException("No CallbackHandler provided");
    }

    NameCallback nameCallback = new NameCallback("Username: ");
    PasswordCallback passwordCallback = new PasswordCallback(
      "Password: ",
      false
    );
    try {
      callbackHandler.handle(new Callback[] { nameCallback, passwordCallback });
    } catch (IOException | UnsupportedCallbackException e) {
      log.error("Error handling callbacks", e);
      throw new LoginException("Callback handling failed: " + e.getMessage());
    }

    String username = nameCallback.getName();
    char[] passwordChars = passwordCallback.getPassword();
    // Очищаем пароль как можно раньше
    if (passwordCallback != null) {
      passwordCallback.clearPassword();
    }
    if (username == null || passwordChars == null) {
      log.warn("Username or password not provided via callbacks.");
      return false; // Аутентификация не удалась
    }
    String password = new String(passwordChars);

    log.debug("Attempting login for user: {}", username);

    String xmlFilePath = (String) options.get("xmlUserFile");
    if (xmlFilePath == null || xmlFilePath.isEmpty()) {
      throw new LoginException(
        "XML user file path not specified in JAAS config options (xmlUserFile)"
      );
    }
    log.debug("Loading users from: {}", xmlFilePath);

    try (
      InputStream xmlStream = new ClassPathResource(
        xmlFilePath.replace("classpath:", "")
      ).getInputStream()
    ) {
      DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
      DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
      Document doc = dBuilder.parse(xmlStream);
      doc.getDocumentElement().normalize();

      NodeList nList = doc.getElementsByTagName("user");

      for (int i = 0; i < nList.getLength(); i++) {
        Element userElement = (Element) nList.item(i);
        String xmlUsername = userElement.getAttribute("username");

        if (username.equals(xmlUsername)) {
          String xmlPasswordHash = userElement.getAttribute("password");
          String xmlRoles = userElement.getAttribute("roles");

          if (passwordEncoder.matches(password, xmlPasswordHash)) {
            log.info("User '{}' authenticated successfully.", username);
            succeeded = true;
            authenticatedUsername = username;

            // Добавляем Principal для имени пользователя
            principalsToAdd.add(new UserPrincipal(authenticatedUsername));

            // Добавляем роли как RolePrincipal
            if (xmlRoles != null && !xmlRoles.isEmpty()) {
              Arrays.stream(xmlRoles.split(","))
                .map(String::trim)
                .filter(role -> !role.isEmpty())
                .forEach(role -> principalsToAdd.add(new RolePrincipal(role))); // Сохраняем во временный список
            }
            log.debug(
              "User '{}' granted principals (to be added on commit): {}",
              username,
              principalsToAdd
            );
            return true; // Аутентификация успешна
          } else {
            log.warn("Password mismatch for user '{}'", username);
            return false; // Неверный пароль
          }
        }
      }

      log.warn("User '{}' not found in {}", username, xmlFilePath);
      return false; // Пользователь не найден
    } catch (Exception e) {
      log.error("Error during XML parsing or authentication", e);
      throw new LoginException(
        "Authentication failed due to internal error: " + e.getMessage()
      );
    }
  }

  @Override
  public boolean commit() throws LoginException {
    if (!succeeded) {
      log.trace(
        "XmlLoginModule commit: authentication failed or login() not called successfully."
      );
      clearState(); // Очищаем на всякий случай
      return false;
    }

    // Добавляем сохраненные principals в Subject
    if (subject.isReadOnly()) {
      throw new LoginException("Subject is Readonly, failed to add Principals");
    }
    for (Principal p : principalsToAdd) {
      if (!subject.getPrincipals().contains(p)) {
        subject.getPrincipals().add(p);
        log.trace("Added Principal '{}' to subject", p);
      } else {
        log.trace("Principal '{}' already exists in subject", p);
      }
    }

    log.debug(
      "XmlLoginModule commit successful for user '{}'",
      authenticatedUsername
    );
    return true;
  }

  @Override
  public boolean abort() throws LoginException {
    log.trace("XmlLoginModule abort called.");
    if (!succeeded) {
      log.trace("Abort: Login never succeeded.");
      return false; // Ничего не делаем, если login не удался
    } else {
      // Если login удался, но commit не был вызван или не удался,
      // очищаем состояние
      log.trace(
        "Abort: Login succeeded but commit possibly failed. Clearing state."
      );
      clearState();
      succeeded = false;
      return true;
    }
  }

  @Override
  public boolean logout() throws LoginException {
    log.debug(
      "XmlLoginModule logout called for subject containing principals: {}",
      subject.getPrincipals()
    );
    if (subject.isReadOnly()) {
      throw new LoginException(
        "Subject is Readonly, failed to remove Principals"
      );
    }
    // Удаляем principals, добавленные этим модулем (из principalsToAdd, если они были успешно добавлены)
    // principalsToAdd уже очищен в abort/commit/login, так что используем то, что знаем
    Set<Principal> principalsToRemove = new HashSet<>();
    if (authenticatedUsername != null) {
      principalsToRemove.add(new UserPrincipal(authenticatedUsername));
    }
    // Ищем добавленные роли по имени, т.к. список principalsToAdd может быть уже очищен
    // Это не идеально, но лучше, чем ничего. В реальном мире хранили бы добавленные Principals.
    subject.getPrincipals(RolePrincipal.class).forEach(principalsToRemove::add);

    if (!principalsToRemove.isEmpty()) {
      int initialSize = subject.getPrincipals().size();
      subject.getPrincipals().removeAll(principalsToRemove);
      log.debug(
        "Attempted to remove principals: {}. Subject principals before: {}, after: {}",
        principalsToRemove,
        initialSize,
        subject.getPrincipals().size()
      );
    } else {
      log.debug("No principals identified for removal during logout.");
    }

    clearState();
    succeeded = false;
    log.debug("Logout completed.");
    return true;
  }

  private void clearState() {
    authenticatedUsername = null;
    principalsToAdd.clear();
    // succeeded сбрасывается в login() и abort()
  }

  // Простой внутренний класс для UserPrincipal
  private static class UserPrincipal implements Principal, Serializable {

    private static final long serialVersionUID = 1L;
    private final String name;

    UserPrincipal(String name) {
      Objects.requireNonNull(name, "UserPrincipal name cannot be null");
      this.name = name;
    }

    @Override
    public String getName() {
      return name;
    }

    @Override
    public boolean equals(Object o) {
      return (
        this == o ||
        (o instanceof UserPrincipal &&
          Objects.equals(name, ((UserPrincipal) o).name))
      );
    }

    @Override
    public int hashCode() {
      return Objects.hash(name);
    }

    @Override
    public String toString() {
      return "UserPrincipal{" + "name='" + name + '\'' + '}';
    }
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/security/RolePrincipal.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.security.jaas;

import java.io.Serializable;
import java.security.Principal;
import java.util.Objects;

// Principal для представления роли пользователя
public class RolePrincipal implements Principal, Serializable {

  private static final long serialVersionUID = 1L;
  private final String name;

  public RolePrincipal(String name) {
    if (name == null) {
      throw new NullPointerException("Role name cannot be null.");
    }
    // Сохраняем имя роли как есть (например, "ROLE_USER")
    this.name = name;
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    RolePrincipal that = (RolePrincipal) o;
    return Objects.equals(name, that.name);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name);
  }

  @Override
  public String toString() {
    return "RolePrincipal{" + "name='" + name + '\'' + '}';
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/entity/enums/TransferStatus.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.entity.enums;

public enum TransferStatus {
    PENDING,
    PROCESSING,
    AWAITING_CONFIRMATION, // Ожидание ввода кода подтверждения
    SUCCESSFUL,
    FAILED,
    INSUFFICIENT_FUNDS,
    BANK_NOT_FOUND,
    INVALID_CODE,
    CANCELLED,
    PHONE_FORMAT_ERROR,
    BANK_REQUEST_ERROR,
    CODE_VERIFICATION_ERROR,
    BLOCKED
}
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/entity/Transfer.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import ru.sberbank.sbp.lab2.transfer_service.entity.enums.TransferStatus;

@Entity
@Table(name = "transfers") // Укажем имя таблицы
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Transfer {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private UUID id;

  @NotBlank
  @Pattern(regexp = "\\d{10}")
  @Column(nullable = false, length = 10)
  private String senderPhoneNumber;

  @NotBlank
  @Pattern(regexp = "\\d{10}")
  @Column(nullable = false, length = 10)
  private String recipientPhoneNumber;

  @NotNull
  @DecimalMin("0.01")
  @Column(nullable = false, precision = 19, scale = 2)
  private BigDecimal amount;

  @NotBlank
  @Column(nullable = false)
  private String recipientBankId;

  @Column(nullable = true) // Имя может быть не сразу известно
  private String recipientBankName;

  @NotNull
  @Enumerated(EnumType.STRING)
  @Column(nullable = false)
  private TransferStatus status;

  @NotNull
  @Column(nullable = false)
  private LocalDateTime createdAt;

  private LocalDateTime completedAt;

  @Column(length = 6)
  private String confirmationCode;

  // ID транзакции в СБП (если есть)
  private String sbpTransactionId;

  @Column(nullable = false)
  private int retryCount = 0;

  private String failureReason;

  @Version // Для оптимистичной блокировки
  private Long version;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/integration/models/SbpTransferResponse.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.integration.models;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

// DTO для получения ответа от SBP Adapter
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SbpTransferResponse {

  private boolean success;
  private String sbpTransactionId;
  private String errorMessage;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/integration/models/BankInfo.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.integration.models;

import lombok.Data;
import lombok.NoArgsConstructor;

// DTO для получения ответа от SBP Adapter
@Data
@NoArgsConstructor
public class BankInfo {

  private String bankId;
  private String bankName;
  private boolean supportsSbp;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/integration/models/SbpTransferRequestDto.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.integration.models;

import java.math.BigDecimal;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

// DTO для отправки запроса в SBP Adapter
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SbpTransferRequestDto {

  private String senderPhoneNumber;
  private String recipientPhoneNumber;
  private BigDecimal amount;
  private UUID correlationId;
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/integration/SbpSystemServiceClient.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.integration;

import java.util.Optional;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;
import ru.sberbank.sbp.lab2.transfer_service.entity.Transfer;
import ru.sberbank.sbp.lab2.transfer_service.integration.models.BankInfo;
import ru.sberbank.sbp.lab2.transfer_service.integration.models.SbpTransferRequestDto;
import ru.sberbank.sbp.lab2.transfer_service.integration.models.SbpTransferResponse;
import ru.sberbank.sbp.lab2.transfer_service.service.SbpSystemService; // Импортируем интерфейс

@Service
@Slf4j
public class SbpSystemServiceClient implements SbpSystemService {

  private final RestTemplate restTemplate;
  private final String sbpAdapterBaseUrl;

  // Внедряем RestTemplate и базовый URL из конфигурации
  public SbpSystemServiceClient(
    @Qualifier("sbpAdapterRestTemplate") RestTemplate restTemplate, // Используем квалификатор
    @Value("${integration.sbp-adapter.base-url}") String sbpAdapterBaseUrl
  ) {
    this.restTemplate = restTemplate;
    this.sbpAdapterBaseUrl = sbpAdapterBaseUrl;
  }

  @Override
  public Optional<BankInfo> findRecipientBank(String phoneNumber) {
    String url = UriComponentsBuilder.fromHttpUrl(sbpAdapterBaseUrl)
      .path("/api/sbp/banks")
      .queryParam("phoneNumber", phoneNumber)
      .toUriString();

    log.debug("Calling SBP Adapter to find bank: {}", url);
    try {
      ResponseEntity<BankInfo> response = restTemplate.getForEntity(
        url,
        BankInfo.class
      );
      if (
        response.getStatusCode().is2xxSuccessful() && response.getBody() != null
      ) {
        log.info(
          "SBP Adapter found bank for phone {}: {}",
          phoneNumber,
          response.getBody()
        );
        return Optional.of(response.getBody());
      } else {
        // Это не должно происходить при 2xx, но на всякий случай
        log.warn(
          "SBP Adapter returned status {} for find bank request for phone {}",
          response.getStatusCode(),
          phoneNumber
        );
        return Optional.empty();
      }
    } catch (HttpClientErrorException e) {
      if (e.getStatusCode() == HttpStatusCode.valueOf(404)) {
        log.warn(
          "SBP Adapter returned 404 Not Found for phone {}",
          phoneNumber
        );
        return Optional.empty(); // Банк не найден
      } else {
        log.error(
          "SBP Adapter client error on find bank for phone {}: Status={}, Body={}",
          phoneNumber,
          e.getStatusCode(),
          e.getResponseBodyAsString(),
          e
        );
        // Бросаем исключение или возвращаем empty? Зависит от политики.
        // Пока вернем empty, чтобы не прерывать, но логируем как ERROR.
        return Optional.empty();
      }
    } catch (RestClientException e) {
      log.error(
        "SBP Adapter connection error on find bank for phone {}: {}",
        phoneNumber,
        e.getMessage(),
        e
      );
      // Ошибка сети - возвращаем empty
      return Optional.empty();
    }
  }

  @Override
  public SbpTransferResponse processTransferViaSbp(Transfer transfer) {
    String url = UriComponentsBuilder.fromHttpUrl(sbpAdapterBaseUrl)
      .path("/api/sbp/transfers")
      .toUriString();

    SbpTransferRequestDto requestDto = SbpTransferRequestDto.builder()
      .senderPhoneNumber(transfer.getSenderPhoneNumber())
      .recipientPhoneNumber(transfer.getRecipientPhoneNumber())
      .amount(transfer.getAmount())
      .correlationId(transfer.getId())
      .build();

    log.debug(
      "Calling SBP Adapter to process transfer {}: {}",
      transfer.getId(),
      url
    );
    try {
      ResponseEntity<SbpTransferResponse> response = restTemplate.postForEntity(
        url,
        requestDto,
        SbpTransferResponse.class
      );

      if (
        response.getStatusCode().is2xxSuccessful() && response.getBody() != null
      ) {
        SbpTransferResponse sbpResponse = response.getBody();
        log.info(
          "SBP Adapter returned result for transfer {}: success={}, message={}",
          transfer.getId(),
          sbpResponse.isSuccess(),
          sbpResponse.getErrorMessage()
        );
        return sbpResponse;
      } else {
        log.error(
          "SBP Adapter returned unexpected status {} for process transfer request for id {}",
          response.getStatusCode(),
          transfer.getId()
        );
        // Возвращаем неуспех, если статус не 2xx
        return SbpTransferResponse.builder()
          .success(false)
          .errorMessage(
            "SBP Adapter communication error: status " +
            response.getStatusCode()
          )
          .build();
      }
    } catch (RestClientException e) {
      log.error(
        "SBP Adapter connection error on process transfer for id {}: {}",
        transfer.getId(),
        e.getMessage(),
        e
      );
      // Возвращаем неуспех при ошибке сети
      return SbpTransferResponse.builder()
        .success(false)
        .errorMessage("SBP Adapter connection error: " + e.getMessage())
        .build();
    }
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/integration/RestTemplateConfig.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.integration;

import java.time.Duration;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {

  @Bean
  @Qualifier("sbpAdapterRestTemplate")
  public RestTemplate sbpAdapterRestTemplate(RestTemplateBuilder builder) {
    return builder
      .setConnectTimeout(Duration.ofSeconds(3)) // Таймаут соединения
      .setReadTimeout(Duration.ofSeconds(10)) // Таймаут чтения ответа
      .build();
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/advice/GlobalExceptionHandler.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.advice;

import java.time.Instant;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import ru.sberbank.sbp.lab2.transfer_service.dto.ErrorResponse;
import ru.sberbank.sbp.lab2.transfer_service.exception.*;

@RestControllerAdvice // Перехватывает исключения со всех @RestController
@Slf4j
public class GlobalExceptionHandler {

  // Обработчик для наших базовых исключений (кроме тех, что с @ResponseStatus)
  @ExceptionHandler(TransferBaseException.class)
  public ResponseEntity<ErrorResponse> handleTransferBaseException(
    TransferBaseException ex,
    WebRequest request
  ) {
    // Ищем аннотацию @ResponseStatus на классе исключения
    ResponseStatus responseStatus = ex
      .getClass()
      .getAnnotation(ResponseStatus.class);
    HttpStatus status = (responseStatus != null)
      ? responseStatus.value()
      : HttpStatus.INTERNAL_SERVER_ERROR; // По умолчанию 500
    String reason = (responseStatus != null &&
        !responseStatus.reason().isEmpty())
      ? responseStatus.reason()
      : status.getReasonPhrase();

    log.error(
      "TransferBaseException caught: Status: {}, Reason: {}, Message: {}",
      status,
      reason,
      ex.getMessage(),
      ex
    );

    ErrorResponse errorResponse = new ErrorResponse(
      Instant.now().toString(),
      status.value(),
      reason, // Используем reason из аннотации или стандартный
      ex.getMessage(), // Сообщение из исключения
      request.getDescription(false).substring(4) // Получаем путь запроса (uri=...)
    );
    return new ResponseEntity<>(errorResponse, status);
  }

  // Обработчик для ошибок валидации (@Valid в контроллере)
  @ExceptionHandler(MethodArgumentNotValidException.class)
  @ResponseStatus(HttpStatus.BAD_REQUEST) // Всегда 400 Bad Request
  public ErrorResponse handleValidationExceptions(
    MethodArgumentNotValidException ex,
    WebRequest request
  ) {
    // Собираем все сообщения об ошибках валидации полей
    String errors = ex
      .getBindingResult()
      .getFieldErrors()
      .stream()
      .map(error -> error.getField() + ": " + error.getDefaultMessage())
      .collect(Collectors.joining("; "));
    log.warn("Validation errors: {}", errors);

    return new ErrorResponse(
      Instant.now().toString(),
      HttpStatus.BAD_REQUEST.value(),
      "Validation Failed",
      errors, // Сообщения об ошибках полей
      request.getDescription(false).substring(4)
    );
  }

  // Обработчик для всех остальных непредвиденных исключений
  @ExceptionHandler(Exception.class)
  @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) // Всегда 500
  public ErrorResponse handleAllUncaughtException(
    Exception ex,
    WebRequest request
  ) {
    log.error("Unhandled exception caught: {}", ex.getMessage(), ex);

    return new ErrorResponse(
      Instant.now().toString(),
      HttpStatus.INTERNAL_SERVER_ERROR.value(),
      "Internal Server Error",
      "An unexpected error occurred. Please contact support.", // Общее сообщение
      request.getDescription(false).substring(4)
    );
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/controller/TransferController.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.controller;

import jakarta.validation.Valid;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import ru.sberbank.sbp.lab2.transfer_service.dto.*;
import ru.sberbank.sbp.lab2.transfer_service.entity.Transfer;
import ru.sberbank.sbp.lab2.transfer_service.service.TransferService;

@RestController
@RequestMapping("/api/transfers")
@RequiredArgsConstructor
@Slf4j
public class TransferController {

  private final TransferService transferService;

  // --- Эндпоинт инициации перевода ---
  @PostMapping
  public ResponseEntity<TransferInitiationResponse> initiateTransfer(
    @Valid @RequestBody InitiateTransferRequest request,
    @RequestHeader("X-Phone-Number") String senderPhoneNumber
  ) {
    log.info(
      "Received transfer initiation request from {} for recipient {} amount {}",
      senderPhoneNumber,
      request.getRecipientPhoneNumber(),
      request.getAmount()
    );

    // Вызов метода сервиса
    TransferInitiationResponse response = transferService.initiateTransfer(
      senderPhoneNumber,
      request.getRecipientPhoneNumber(),
      request.getAmount()
    );

    // Возвращаем ответ с ID перевода, статусом и кодом 201 Created
    return new ResponseEntity<>(response, HttpStatus.CREATED);
  }

  // --- Эндпоинт подтверждения перевода ---
  @PostMapping("/{transferId}/confirm")
  public ResponseEntity<TransferConfirmationResponse> confirmTransfer(
    @PathVariable UUID transferId,
    @Valid @RequestBody ConfirmTransferRequest request,
    @RequestHeader("X-Phone-Number") String senderPhoneNumber
  ) {
    log.info(
      "Received confirmation request for transferId: {} with code: {} from: {}",
      transferId,
      request.getConfirmationCode(),
      senderPhoneNumber
    );

    // Вызов метода сервиса
    TransferConfirmationResponse response = transferService.confirmTransfer(
      transferId,
      request.getConfirmationCode()
    );

    // Возвращаем ответ со статусом и кодом 200 OK
    return ResponseEntity.ok(response);
  }

  // --- Эндпоинт получения статуса перевода ---
  @GetMapping("/{transferId}")
  public ResponseEntity<Transfer> getTransferStatus(
    @PathVariable UUID transferId,
    @RequestHeader("X-Phone-Number") String senderPhoneNumber
  ) {
    log.info(
      "Received status request for transferId: {} from: {}",
      transferId,
      senderPhoneNumber
    );

    // Вызов метода сервиса
    Transfer transfer = transferService.getTransferStatus(transferId);

    // Возвращаем найденный перевод и код 200 OK
    // Если сервис не найдет перевод, он должен бросить исключение
    return ResponseEntity.ok(transfer);
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/TransferServiceApplication.java
contents:
package ru.sberbank.sbp.lab2.transfer_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;
import org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration;

@SpringBootApplication(
  exclude = {
    DataSourceAutoConfiguration.class,
    DataSourceTransactionManagerAutoConfiguration.class,
    SqlInitializationAutoConfiguration.class,
  }
)
// @EnableJms // Можно убрать, если в этом сервисе нет @JmsListener
public class TransferServiceApplication {

  public static void main(String[] args) {
    SpringApplication.run(TransferServiceApplication.class, args);
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/service/TransferService.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.service;

import java.math.BigDecimal;
import java.util.UUID;
import ru.sberbank.sbp.lab2.transfer_service.dto.TransferConfirmationResponse;
import ru.sberbank.sbp.lab2.transfer_service.dto.TransferInitiationResponse;
import ru.sberbank.sbp.lab2.transfer_service.entity.Transfer;

/**
 * Интерфейс сервиса управления переводами.
 * Определяет основные операции бизнес-логики переводов.
 */
public interface TransferService {
  /**
   * Инициирует новый перевод.
   *
   * @param senderPhoneNumber    Номер телефона отправителя.
   * @param recipientPhoneNumber Номер телефона получателя.
   * @param amount               Сумма перевода.
   * @return Ответ с ID перевода и его начальным статусом.
   * @throws RuntimeException если возникают ошибки валидации, связи с другими сервисами и т.д.
   *                          (позже конкретизируем типы исключений).
   */
  TransferInitiationResponse initiateTransfer(
    String senderPhoneNumber,
    String recipientPhoneNumber,
    BigDecimal amount
  );

  /**
   * Подтверждает инициированный перевод с помощью кода.
   *
   * @param transferId       Уникальный идентификатор перевода.
   * @param confirmationCode Код подтверждения, введенный пользователем.
   * @return Ответ с финальным статусом перевода.
   * @throws ru.sberbank.sbp.lab2.transfer_service.exception.TransferNotFoundException если перевод не найден.
   * @throws RuntimeException если возникают другие ошибки (неверный код, таймаут, ошибки СБП и т.д.).
   */
  TransferConfirmationResponse confirmTransfer(
    UUID transferId,
    String confirmationCode
  );

  /**
   * Получает текущий статус перевода по его ID.
   *
   * @param transferId Уникальный идентификатор перевода.
   * @return Сущность Transfer с актуальной информацией.
   * @throws ru.sberbank.sbp.lab2.transfer_service.exception.TransferNotFoundException если перевод не найден.
   */
  Transfer getTransferStatus(UUID transferId);
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/service/SbpSystemService.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.service;

import java.util.Optional;
import ru.sberbank.sbp.lab2.transfer_service.entity.Transfer;
import ru.sberbank.sbp.lab2.transfer_service.integration.models.BankInfo;
import ru.sberbank.sbp.lab2.transfer_service.integration.models.SbpTransferResponse;

public interface SbpSystemService {
  /**
   * Находит банк получателя по номеру телефона через SBP Adapter.
   * @param phoneNumber Номер телефона получателя.
   * @return Optional с информацией о банке, если найден, иначе Optional.empty().
   */
  Optional<BankInfo> findRecipientBank(String phoneNumber);

  /**
   * Инициирует обработку перевода через SBP Adapter.
   * @param transfer Детали перевода.
   * @return Ответ от SBP Adapter с результатом операции.
   */
  SbpTransferResponse processTransferViaSbp(Transfer transfer);
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/service/TransferServiceImpl.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.service;

import jakarta.transaction.Transactional; // Используем jakarta @Transactional
import java.math.BigDecimal;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Optional;
import java.util.UUID;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
// Импортируем DTO
import ru.sberbank.sbp.lab2.transfer_service.dto.TransferConfirmationResponse;
import ru.sberbank.sbp.lab2.transfer_service.dto.TransferInitiationResponse;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.CompleteTransferCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.ReleaseFundsCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.ReserveFundsCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendConfirmationCodeCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendFailureNotificationCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendSuccessNotificationCommand;
// Импортируем сущности и enums
import ru.sberbank.sbp.lab2.transfer_service.entity.Transfer;
import ru.sberbank.sbp.lab2.transfer_service.entity.enums.TransferStatus;
// Импортируем исключения
import ru.sberbank.sbp.lab2.transfer_service.exception.InvalidInputDataException;
import ru.sberbank.sbp.lab2.transfer_service.exception.InvalidRecipientException;
import ru.sberbank.sbp.lab2.transfer_service.exception.InvalidTransferStateException;
import ru.sberbank.sbp.lab2.transfer_service.exception.TransferLimitExceededException;
import ru.sberbank.sbp.lab2.transfer_service.exception.TransferNotFoundException;
// Интеграция
import ru.sberbank.sbp.lab2.transfer_service.integration.models.BankInfo;
import ru.sberbank.sbp.lab2.transfer_service.integration.models.SbpTransferResponse;
// Импортируем репозиторий и другие сервисы/компоненты
import ru.sberbank.sbp.lab2.transfer_service.jms.JmsSender;
import ru.sberbank.sbp.lab2.transfer_service.repository.TransferRepository;
import ru.sberbank.sbp.lab2.transfer_service.service.PhoneValidationService;
// Импортируем интерфейсы сервисов
import ru.sberbank.sbp.lab2.transfer_service.service.SbpSystemService;

@Service
@RequiredArgsConstructor
@Slf4j
public class TransferServiceImpl implements TransferService {

  private final TransferRepository transferRepository;
  private final JmsSender jmsSender;
  // Внедряем реализации через интерфейсы
  private final SbpSystemService sbpSystemService;
  private final PhoneValidationService phoneValidationService;

  private static final int MAX_CONFIRMATION_ATTEMPTS = 3;
  private static final BigDecimal DAILY_TRANSFER_LIMIT = new BigDecimal(
    "150000.00"
  );

  @Override
  @Transactional
  public TransferInitiationResponse initiateTransfer(
    String senderPhoneNumber,
    String recipientPhoneNumber,
    BigDecimal amount
  ) {
    log.info(
      "[TransferService] Initiating transfer from {} to {} amount {}",
      senderPhoneNumber,
      recipientPhoneNumber,
      amount
    );

    // 1. Валидация номеров
    if (!phoneValidationService.validatePhoneFormat(senderPhoneNumber)) {
      throw new InvalidInputDataException(
        "Invalid sender phone number format: " + senderPhoneNumber
      );
    }
    if (!phoneValidationService.validatePhoneFormat(recipientPhoneNumber)) {
      throw new InvalidInputDataException(
        "Invalid recipient phone number format: " + recipientPhoneNumber
      );
    }
    if (senderPhoneNumber.equals(recipientPhoneNumber)) {
      throw new InvalidInputDataException(
        "Sender and recipient phone numbers cannot be the same."
      );
    }

    // 2. Проверка лимитов (заглушка)
    LocalDateTime startOfDay = LocalDateTime.now().with(LocalTime.MIN);
    BigDecimal currentDayAmount =
      transferRepository.sumSuccessfulTransferAmountsByPhoneNumberAndDate(
        senderPhoneNumber,
        startOfDay
      );
    log.info(
      "[TransferService] Current successful transfers amount for {} today: {}",
      senderPhoneNumber,
      currentDayAmount
    );

    if (currentDayAmount.add(amount).compareTo(DAILY_TRANSFER_LIMIT) > 0) {
      BigDecimal remainingLimit = DAILY_TRANSFER_LIMIT.subtract(
        currentDayAmount
      );
      String message = String.format(
        "Daily transfer limit exceeded. Current amount: %s, Requested: %s, Limit: %s, Remaining: %s",
        currentDayAmount,
        amount,
        DAILY_TRANSFER_LIMIT,
        remainingLimit.max(BigDecimal.ZERO) // Показываем 0, если уже превышен
      );
      log.warn("[TransferService] {}", message);
      throw new TransferLimitExceededException(message); // Бросаем исключение
    }
    log.info(
      "[TransferService] Daily limit check passed for {}",
      senderPhoneNumber
    );

    // 3. Поиск банка получателя через SBP Adapter (REST вызов)
    Optional<BankInfo> bankInfoOpt = sbpSystemService.findRecipientBank(
      recipientPhoneNumber
    );
    if (bankInfoOpt.isEmpty()) {
      log.warn(
        "[TransferService] Failed to find recipient bank info via SBP Adapter for phone {}",
        recipientPhoneNumber
      );
      throw new InvalidRecipientException(
        "Recipient's bank not found, does not support SBP, or SBP adapter error."
      );
    }
    BankInfo recipientBank = bankInfoOpt.get();

    // 4. Создаем перевод в статусе PENDING
    Transfer transfer = Transfer.builder()
      .senderPhoneNumber(senderPhoneNumber)
      .recipientPhoneNumber(recipientPhoneNumber)
      .amount(amount)
      .recipientBankId(recipientBank.getBankId())
      .recipientBankName(recipientBank.getBankName())
      .status(TransferStatus.PENDING)
      .createdAt(LocalDateTime.now())
      .confirmationCode(generateSecureConfirmationCode())
      .retryCount(0)
      .build();
    Transfer savedTransfer = transferRepository.save(transfer);
    log.info(
      "[TransferService] Transfer entity created with id: {} status: {}",
      savedTransfer.getId(),
      savedTransfer.getStatus()
    );

    // 5. Отправляем команду на резервирование средств (JMS)
    ReserveFundsCommand reserveCmd = ReserveFundsCommand.builder()
      .phoneNumber(senderPhoneNumber)
      .amount(amount)
      .correlationId(savedTransfer.getId())
      .build();
    try {
      jmsSender.sendReserveFundsCommand(reserveCmd);
      log.info(
        "[TransferService] Sent ReserveFundsCommand for transfer id: {}",
        savedTransfer.getId()
      );
    } catch (Exception e) {
      log.error(
        "[TransferService] Failed to send ReserveFundsCommand for transfer id: {}. Initiating rollback.",
        savedTransfer.getId(),
        e
      );
      throw new RuntimeException(
        "Failed to initiate transfer due to JMS send error for id: " +
        savedTransfer.getId(),
        e
      );
    }

    // 6. Обновляем статус на AWAITING_CONFIRMATION
    savedTransfer.setStatus(TransferStatus.AWAITING_CONFIRMATION);
    transferRepository.save(savedTransfer); // Это сохранение будет частью JTA транзакции
    log.info(
      "[TransferService] Transfer status updated to AWAITING_CONFIRMATION for id: {}",
      savedTransfer.getId()
    );

    // 7. Отправляем команду на отправку кода подтверждения (JMS - Fire-and-forget)
    SendConfirmationCodeCommand codeCmd = SendConfirmationCodeCommand.builder()
      .phoneNumber(senderPhoneNumber)
      .code(savedTransfer.getConfirmationCode())
      .correlationId(savedTransfer.getId())
      .build();
    try {
      // Отправка вне основной транзакции или обработка ошибки без отката
      jmsSender.sendConfirmationCodeCommand(codeCmd);
    } catch (Exception e) {
      log.error(
        "[TransferService] Failed to send SendConfirmationCodeCommand for transfer {}. Continuing...",
        savedTransfer.getId(),
        e
      );
    }

    return new TransferInitiationResponse(
      savedTransfer.getId(),
      savedTransfer.getStatus(),
      savedTransfer.getRecipientBankName()
    );
  }

  @Override
  @Transactional
  public TransferConfirmationResponse confirmTransfer(
    UUID transferId,
    String confirmationCode
  ) {
    log.info(
      "[TransferService] Confirming transfer {} with code {}",
      transferId,
      confirmationCode
    );

    Transfer transfer = findTransferByIdOrFail(transferId);

    // 1. Проверка статуса
    if (transfer.getStatus() != TransferStatus.AWAITING_CONFIRMATION) {
      log.warn(
        "[TransferService] Transfer {} is not awaiting confirmation (status: {})",
        transferId,
        transfer.getStatus()
      );
      throw new InvalidTransferStateException(
        "Transfer is not awaiting confirmation. Current status: " +
        transfer.getStatus()
      );
    }

    // 2. Проверка кода
    if (!transfer.getConfirmationCode().equals(confirmationCode)) {
      log.warn(
        "[TransferService] Invalid confirmation code for transfer {}",
        transferId
      );
      transfer.setRetryCount(transfer.getRetryCount() + 1);
      String failureMessage;
      boolean maxAttemptsReached =
        transfer.getRetryCount() >= MAX_CONFIRMATION_ATTEMPTS;

      if (maxAttemptsReached) {
        transfer.setStatus(TransferStatus.FAILED);
        String reason = "Invalid confirmation code - max attempts exceeded";
        transfer.setFailureReason(reason);
        failureMessage = "Invalid confirmation code. Max attempts exceeded.";
        // Транзакция будет включать обновление статуса и отправку команды отмены
        sendReleaseFundsCommand(transfer, reason);
        sendFailureNotificationCommand(transfer); // Уведомление
      } else {
        failureMessage =
          "Invalid confirmation code. Attempts left: " +
          (MAX_CONFIRMATION_ATTEMPTS - transfer.getRetryCount());
        // Просто сохраняем счетчик попыток, статус не меняем
      }
      transferRepository.save(transfer); // Сохраняем изменения (статус или счетчик)
      return new TransferConfirmationResponse(
        transferId,
        transfer.getStatus(),
        failureMessage
      );
    }

    // 3. Взаимодействие с SBP Adapter (REST вызов)
    SbpTransferResponse sbpResponse = sbpSystemService.processTransferViaSbp(
      transfer
    );

    // Вся последующая логика (обновление БД + отправка JMS) должна быть атомарной
    if (sbpResponse.isSuccess()) {
      // 4. Отправляем команду на завершение в account-service (JMS)
      CompleteTransferCommand completeCmd = CompleteTransferCommand.builder()
        .senderPhoneNumber(transfer.getSenderPhoneNumber())
        .recipientPhoneNumber(transfer.getRecipientPhoneNumber())
        .amount(transfer.getAmount())
        .correlationId(transfer.getId())
        .build();
      try {
        jmsSender.sendCompleteTransferCommand(completeCmd);
        log.info(
          "[TransferService] Sent CompleteTransferCommand for transfer id: {}",
          transfer.getId()
        );
      } catch (Exception e) {
        log.error(
          "[TransferService] Failed to send CompleteTransferCommand for transfer id: {}. Initiating rollback.",
          transfer.getId(),
          e
        );
        throw new RuntimeException(
          "Failed to confirm transfer due to JMS send error for id: " +
          transfer.getId(),
          e
        );
      }

      // 5. Обновляем статус перевода в локальной БД
      transfer.setStatus(TransferStatus.SUCCESSFUL);
      transfer.setSbpTransactionId(sbpResponse.getSbpTransactionId()); // Сохраняем ID из SBP
      transfer.setCompletedAt(LocalDateTime.now());
      transfer.setRetryCount(0);
      transfer.setFailureReason(null);
      transferRepository.save(transfer); // Будет в JTA транзакции
      log.info(
        "[TransferService] Transfer {} status updated to SUCCESSFUL",
        transferId
      );

      // 6. Отправляем команду уведомления об успехе (JMS Fire-and-forget)
      sendSuccessNotificationCommand(transfer);

      return new TransferConfirmationResponse(
        transferId,
        TransferStatus.SUCCESSFUL,
        "Transfer successful"
      );
    } else {
      // SBP обработка не удалась
      String reason = sbpResponse.getErrorMessage() != null
        ? sbpResponse.getErrorMessage()
        : "SBP processing failed (unknown reason)";
      log.error(
        "[TransferService] SBP processing failed for transfer {}: {}",
        transferId,
        reason
      );
      transfer.setStatus(TransferStatus.FAILED);
      transfer.setFailureReason(reason);

      // 7. Отправляем команду на отмену резерва (JMS)
      sendReleaseFundsCommand(transfer, reason);
      transferRepository.save(transfer); // Будет в JTA транзакции
      log.info(
        "[TransferService] Transfer {} status updated to FAILED due to SBP error",
        transferId
      );

      // 8. Отправляем команду уведомления об ошибке (JMS Fire-and-forget)
      sendFailureNotificationCommand(transfer);

      return new TransferConfirmationResponse(
        transferId,
        TransferStatus.FAILED,
        reason
      );
    }
  }

  @Override
  @Transactional
  public Transfer getTransferStatus(UUID transferId) {
    log.debug("[TransferService] Getting status for transfer {}", transferId);
    return findTransferByIdOrFail(transferId);
  }

  // --- Вспомогательные методы ---

  private Transfer findTransferByIdOrFail(UUID transferId) {
    return transferRepository
      .findById(transferId)
      .orElseThrow(() -> {
        log.warn("[TransferService] Transfer not found by id: {}", transferId);
        return new TransferNotFoundException(
          "Transfer not found with id: " + transferId
        );
      });
  }

  private String generateSecureConfirmationCode() {
    return String.format("%06d", new SecureRandom().nextInt(1000000));
  }

  // Отправка команды отмены резерва
  private void sendReleaseFundsCommand(Transfer transfer, String reason) {
    log.warn(
      "[TransferService] Sending ReleaseFunds command for transfer {} due to: {}",
      transfer.getId(),
      reason
    );
    ReleaseFundsCommand releaseCmd = ReleaseFundsCommand.builder()
      .phoneNumber(transfer.getSenderPhoneNumber())
      .amount(transfer.getAmount())
      .correlationId(transfer.getId())
      .build();
    try {
      // Эта отправка должна быть частью основной JTA транзакции,
      // т.к. если она не удастся, статус FAILED не должен быть закоммичен.
      // Ошибка здесь вызовет RuntimeException благодаря handleSendError в JmsSender.
      jmsSender.sendReleaseFundsCommand(releaseCmd);
    } catch (Exception e) {
      // Если handleSendError не бросает исключение, логируем критическую ошибку
      log.error(
        "[TransferService] CRITICAL: Failed to send ReleaseFundsCommand for transfer {}. Manual intervention might be required. Error: {}",
        transfer.getId(),
        e.getMessage(),
        e
      );
      throw new RuntimeException(
        "Failed to send ReleaseFundsCommand for transfer " + transfer.getId(),
        e
      );
    }
  }

  // Отправка команды уведомления об успехе
  private void sendSuccessNotificationCommand(Transfer transfer) {
    SendSuccessNotificationCommand successCmd =
      SendSuccessNotificationCommand.builder()
        .senderPhoneNumber(transfer.getSenderPhoneNumber())
        .amount(transfer.getAmount())
        .recipientInfo(
          transfer.getRecipientBankName() +
          "/" +
          transfer.getRecipientPhoneNumber()
        )
        .correlationId(transfer.getId())
        .build();
    try {
      jmsSender.sendSuccessNotificationCommand(successCmd);
    } catch (Exception e) {
      log.error(
        "[TransferService] Failed to send SendSuccessNotificationCommand for transfer {}. Continuing...",
        transfer.getId(),
        e
      );
    }
  }

  // Отправка команды уведомления об ошибке
  private void sendFailureNotificationCommand(Transfer transfer) {
    SendFailureNotificationCommand failCmd =
      SendFailureNotificationCommand.builder()
        .senderPhoneNumber(transfer.getSenderPhoneNumber())
        .amount(transfer.getAmount())
        .reason(transfer.getFailureReason())
        .correlationId(transfer.getId())
        .build();
    try {
      jmsSender.sendFailureNotificationCommand(failCmd);
    } catch (Exception e) {
      log.error(
        "[TransferService] Failed to send SendFailureNotificationCommand for transfer {}. Continuing...",
        transfer.getId(),
        e
      );
    }
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/service/PhoneValidationService.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.service;

public interface PhoneValidationService {
  /**
   * Проверяет корректность формата номера телефона (например, 10 цифр).
   * @param phoneNumber Номер телефона для проверки.
   * @return true, если формат корректный, иначе false.
   */
  boolean validatePhoneFormat(String phoneNumber);
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/service/stub/PhoneValidationServiceStub.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.service.stub;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import ru.sberbank.sbp.lab2.transfer_service.service.PhoneValidationService;

@Service
@Slf4j
public class PhoneValidationServiceStub implements PhoneValidationService {

  private static final String PHONE_REGEX = "\\d{10}";

  @Override
  public boolean validatePhoneFormat(String phoneNumber) {
    boolean isValid = false;
    if (phoneNumber != null) {
      isValid = phoneNumber.matches(PHONE_REGEX);
    }
    log.debug(
      "[PhoneValidationServiceStub] Validating phone format for '{}': {}",
      phoneNumber,
      isValid
    );
    return isValid;
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/jms/JmsSender.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.jms;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.CompleteTransferCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.ReleaseFundsCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.ReserveFundsCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendConfirmationCodeCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendFailureNotificationCommand;
import ru.sberbank.sbp.lab2.transfer_service.dto.jms.SendSuccessNotificationCommand;

@Component
@RequiredArgsConstructor
@Slf4j
public class JmsSender {

  private final JmsTemplate jmsTemplate;

  public void sendReserveFundsCommand(ReserveFundsCommand command) {
    try {
      log.info(
        "Sending command to queue [{}]: CorrelationId: {}",
        JmsConfig.ACCOUNT_RESERVE_FUNDS_QUEUE,
        command.getCorrelationId()
      );
      jmsTemplate.convertAndSend(
        JmsConfig.ACCOUNT_RESERVE_FUNDS_QUEUE,
        command
      );
      log.debug(
        "ReserveFundsCommand with CorrelationId [{}] successfully sent.",
        command.getCorrelationId()
      );
    } catch (Exception e) {
      handleSendError(
        JmsConfig.ACCOUNT_RESERVE_FUNDS_QUEUE,
        command.getCorrelationId(),
        e
      );
    }
  }

  public void sendCompleteTransferCommand(CompleteTransferCommand command) {
    try {
      log.info(
        "Sending command to queue [{}]: CorrelationId: {}",
        JmsConfig.ACCOUNT_COMPLETE_TRANSFER_QUEUE,
        command.getCorrelationId()
      );
      jmsTemplate.convertAndSend(
        JmsConfig.ACCOUNT_COMPLETE_TRANSFER_QUEUE,
        command
      );
      log.debug(
        "CompleteTransferCommand with CorrelationId [{}] successfully sent.",
        command.getCorrelationId()
      );
    } catch (Exception e) {
      handleSendError(
        JmsConfig.ACCOUNT_COMPLETE_TRANSFER_QUEUE,
        command.getCorrelationId(),
        e
      );
    }
  }

  public void sendReleaseFundsCommand(ReleaseFundsCommand command) {
    try {
      log.info(
        "Sending command to queue [{}]: CorrelationId: {}",
        JmsConfig.ACCOUNT_RELEASE_FUNDS_QUEUE,
        command.getCorrelationId()
      );
      jmsTemplate.convertAndSend(
        JmsConfig.ACCOUNT_RELEASE_FUNDS_QUEUE,
        command
      );
      log.debug(
        "ReleaseFundsCommand with CorrelationId [{}] successfully sent.",
        command.getCorrelationId()
      );
    } catch (Exception e) {
      handleSendError(
        JmsConfig.ACCOUNT_RELEASE_FUNDS_QUEUE,
        command.getCorrelationId(),
        e
      );
    }
  }

  // --- Методы для Notification Service ---
  public void sendConfirmationCodeCommand(SendConfirmationCodeCommand command) {
    // Отправка уведомлений может быть менее критичной,
    // поэтому можно не бросать RuntimeException при ошибке, а только логировать.
    try {
      log.info(
        "Sending command to queue [{}]: CorrelationId: {}",
        JmsConfig.NOTIFICATION_SEND_CODE_QUEUE,
        command.getCorrelationId()
      );
      jmsTemplate.convertAndSend(
        JmsConfig.NOTIFICATION_SEND_CODE_QUEUE,
        command
      );
      log.debug(
        "SendConfirmationCodeCommand with CorrelationId [{}] successfully sent.",
        command.getCorrelationId()
      );
    } catch (Exception e) {
      handleNotificationSendError(
        JmsConfig.NOTIFICATION_SEND_CODE_QUEUE,
        command.getCorrelationId(),
        e
      );
    }
  }

  public void sendSuccessNotificationCommand(
    SendSuccessNotificationCommand command
  ) {
    try {
      log.info(
        "Sending command to queue [{}]: CorrelationId: {}",
        JmsConfig.NOTIFICATION_SEND_SUCCESS_QUEUE,
        command.getCorrelationId()
      );
      jmsTemplate.convertAndSend(
        JmsConfig.NOTIFICATION_SEND_SUCCESS_QUEUE,
        command
      );
      log.debug(
        "SendSuccessNotificationCommand with CorrelationId [{}] successfully sent.",
        command.getCorrelationId()
      );
    } catch (Exception e) {
      handleNotificationSendError(
        JmsConfig.NOTIFICATION_SEND_SUCCESS_QUEUE,
        command.getCorrelationId(),
        e
      );
    }
  }

  public void sendFailureNotificationCommand(
    SendFailureNotificationCommand command
  ) {
    try {
      log.info(
        "Sending command to queue [{}]: CorrelationId: {}",
        JmsConfig.NOTIFICATION_SEND_FAILURE_QUEUE,
        command.getCorrelationId()
      );
      jmsTemplate.convertAndSend(
        JmsConfig.NOTIFICATION_SEND_FAILURE_QUEUE,
        command
      );
      log.debug(
        "SendFailureNotificationCommand with CorrelationId [{}] successfully sent.",
        command.getCorrelationId()
      );
    } catch (Exception e) {
      handleNotificationSendError(
        JmsConfig.NOTIFICATION_SEND_FAILURE_QUEUE,
        command.getCorrelationId(),
        e
      );
    }
  }

  // Общий обработчик ошибок для команд уведомлений (можно просто логировать)
  private void handleNotificationSendError(
    String queueName,
    Object correlationId,
    Exception e
  ) {
    log.error(
      "Error sending notification command with CorrelationId [{}] to queue [{}]: {}",
      correlationId,
      queueName,
      e.getMessage(),
      e
    );
    // Не бросаем RuntimeException, чтобы не откатывать основную транзакцию перевода
    // throw new RuntimeException(...)
  }

  // Вспомогательный метод для обработки ошибок
  private void handleSendError(
    String queueName,
    Object correlationId,
    Exception e
  ) {
    log.error(
      "Error sending command with CorrelationId [{}] to queue [{}]: {}",
      correlationId,
      queueName,
      e.getMessage(),
      e
    );
    // Важно откатить транзакцию
    throw new RuntimeException(
      "Failed to send JMS command for CorrelationId: " +
      correlationId +
      " to queue " +
      queueName,
      e
    );
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/jms/JmsConfig.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.jms;

public final class JmsConfig {

  private JmsConfig() {}

  // --- Account Service Queues ---
  public static final String ACCOUNT_RESERVE_FUNDS_QUEUE =
    "account.command.reserve.queue";
  public static final String ACCOUNT_COMPLETE_TRANSFER_QUEUE =
    "account.command.complete.queue";
  public static final String ACCOUNT_RELEASE_FUNDS_QUEUE =
    "account.command.release.queue";

  // --- Notification Service Queues ---
  public static final String NOTIFICATION_SEND_CODE_QUEUE =
    "notification.command.sendcode.queue";
  public static final String NOTIFICATION_SEND_SUCCESS_QUEUE =
    "notification.command.sendsuccess.queue";
  public static final String NOTIFICATION_SEND_FAILURE_QUEUE =
    "notification.command.sendfailure.queue";
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/jms/JmsSenderConfig.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.jms;

// Добавляем импорты
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import jakarta.jms.ConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessageType;

@Configuration
public class JmsSenderConfig {

  @Bean
  public MessageConverter jacksonJmsMessageConverter(
    ObjectMapper objectMapper
  ) {
    MappingJackson2MessageConverter converter =
      new MappingJackson2MessageConverter();
    converter.setTargetType(MessageType.TEXT);
    converter.setTypeIdPropertyName("_type");
    converter.setObjectMapper(objectMapper);
    return converter;
  }

  @Bean
  public ObjectMapper objectMapper() {
    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());
    return mapper;
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/exception/TransferNotFoundException.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Исключение, выбрасываемое, когда перевод не найден по ID.
 * Аннотация @ResponseStatus автоматически вернет 404 Not Found клиенту.
 */
@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Transfer not found") // Добавляем reason
public class TransferNotFoundException extends TransferBaseException { // Наследуемся от базового
    public TransferNotFoundException(String message) {
        super(message);
    }
}
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/exception/TransferLimitExceededException.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Исключение, выбрасываемое при превышении лимита переводов (например, дневного).
 * Аннотация @ResponseStatus вернет 400 Bad Request.
 */
@ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Transfer limit exceeded")
public class TransferLimitExceededException extends TransferBaseException {
    public TransferLimitExceededException(String message) {
        super(message);
    }
}
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/exception/InvalidInputDataException.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.exception;

 import org.springframework.http.HttpStatus;
 import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Исключение для общих ошибок валидации входных данных (дополнительно к Bean Validation).
 * Аннотация @ResponseStatus вернет 400 Bad Request.
 */
 @ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = "Invalid input data")
 public class InvalidInputDataException extends TransferBaseException {
     public InvalidInputDataException(String message) {
         super(message);
     }
 }
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/exception/InvalidRecipientException.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(
  value = HttpStatus.BAD_REQUEST,
  reason = "Invalid recipient or recipient bank unavailable via SBP"
)
public class InvalidRecipientException extends TransferBaseException {

  public InvalidRecipientException(String message) {
    super(message);
  }

  public InvalidRecipientException(String message, Throwable cause) {
    super(message, cause);
  }
}

**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/exception/InvalidTransferStateException.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Исключение, выбрасываемое при попытке выполнить операцию над переводом,
 * находящимся в невалидном для этой операции статусе.
 * Аннотация @ResponseStatus вернет 409 Conflict или 400 Bad Request.
 */
@ResponseStatus(value = HttpStatus.CONFLICT, reason = "Invalid transfer state for operation")
public class InvalidTransferStateException extends TransferBaseException {
    public InvalidTransferStateException(String message) {
        super(message);
    }
}
**====================================**
path: transfer-service/src/main/java/ru/sberbank/sbp/lab2/transfer_service/exception/TransferBaseException.java
contents:
package ru.sberbank.sbp.lab2.transfer_service.exception;

/**
 * Базовый класс для всех кастомных Runtime исключений сервиса переводов.
 */
public abstract class TransferBaseException extends RuntimeException {
    public TransferBaseException(String message) {
        super(message);
    }

    public TransferBaseException(String message, Throwable cause) {
        super(message, cause);
    }
}
**====================================**
path: setup.txt
contents:
CREATE USER sbp_lab_admin WITH LOGIN CREATEDB PASSWORD 'your_admin_password';

psql -U sbp_lab_admin -d postgres -W


-- База и пользователь для transfer-service
CREATE DATABASE transfer_db;
CREATE USER transfer_user WITH PASSWORD 'your_transfer_password';
-- Даем все права на конкретную базу
GRANT ALL PRIVILEGES ON DATABASE transfer_db TO transfer_user;
-- Назначим владельцем (опционально, но полезно)
ALTER DATABASE transfer_db OWNER TO transfer_user;

-- База и пользователь для account-service
CREATE DATABASE account_db;
CREATE USER account_user WITH PASSWORD 'your_account_password';
GRANT ALL PRIVILEGES ON DATABASE account_db TO account_user;
ALTER DATABASE account_db OWNER TO account_user;

-- Проверим список баз и их владельцев
\l



настройки psql
/opt/homebrew/var/postgresql@14

postgresql.conf
max_prepared_transactions = 50   # default is 0

 SHOW max_prepared_transactions;



curl -X POST http://localhost:8080/api/transfers \
         -H "Content-Type: application/json" \
         -H "X-Phone-Number: 9991112222" \
         -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 75.00,
       "bankId": "another-bank"
     }'


INSERT INTO accounts (phone_number, balance, reserved_amount, version) VALUES ('9991112222', 10000.00, 0.00, 0);


curl -X POST http://localhost:8080/api/transfers \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 75.00,
       "bankId": "another-bank"
     }'





TRANSFER_ID="85c63f5c-862d-4c03-8b7d-a26e068fe496"
CONFIRMATION_CODE="537509"

curl -X POST http://localhost:8080/api/transfers/85c63f5c-862d-4c03-8b7d-a26e068fe496/confirm \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "confirmationCode": "537509"
     }'



curl -X POST http://localhost:8080/api/transfers/85c63f5c-862d-4c03-8b7d-a26e068fe496/confirm \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "confirmationCode": "537509"
     }' \
      -i --user user:wrongpassword 

    curl -X POST http://localhost:8080/api/transfers/85c63f5c-862d-4c03-8b7d-a26e068fe496/confirm \
        -H "Content-Type: application/json" \
        -H "X-Phone-Number: 9991112222" \
        -d '{
        "confirmationCode": "537509"
        }' \
        -i --user user:userpass


     
     curl -X POST http://localhost:8080/api/transfers/85c63f5c-862d-4c03-8b7d-a26e068fe496/confirm \
        -H "Content-Type: application/json" \
        -H "X-Phone-Number: 9991112222" \
        -d '{
        "confirmationCode": "537509"
        }' \
        -i --user admin:adminpass


ТЕСТОВЫЕ СЦЕНАРИИ:


Доступ без аутентификации
curl -v -X POST http://localhost:8080/api/transfers \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 10.00,
       "bankId": "test-bank"
     }'


Доступ с неверными кредами
curl -X POST http://localhost:8080/api/transfers \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 15.00,
       "bankId": "test-bank"
     }' \
      -i --user user:wrongpassword


Доступ USER'ом к /api/transfers 
curl -X POST http://localhost:8080/api/transfers \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 15.00,
       "bankId": "100000002"
     }' \
      -i --user user:userpass

Доступ USER'ом к /api/transfers/{id}/ (Получение статуса) - нереальный endpoint, служит для наших тестов только и понимания происходящего
curl -X GET http://localhost:8080/api/transfers/3d5edb38-c016-4b60-8ae3-747aa9bea739 \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 15.00,
       "bankId": "100000002"
     }' \
      -i --user user:userpass

Доступ ADMIN'ом к /api/transfers/{id}/ (Получение статуса) - нереальный endpoint, служит для наших тестов только и понимания происходящего
curl -X GET http://localhost:8080/api/transfers/3d5edb38-c016-4b60-8ae3-747aa9bea739 \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "recipientPhoneNumber": "9993334444",
       "amount": 15.00,
       "bankId": "100000002"
     }' \
      -i --user admin:adminpass

Подтверждение перевода по коду
curl -X POST http://localhost:8080/api/transfers/3d5edb38-c016-4b60-8ae3-747aa9bea739/confirm \
     -H "Content-Type: application/json" \
     -H "X-Phone-Number: 9991112222" \
     -d '{
       "confirmationCode": "207166"
     }' \
      -i --user user:userpass   


brew install jq
**====================================**
path: .idea/lab2.iml
contents:
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
